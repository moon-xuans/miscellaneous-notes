# 阿里巴巴开发手册

## 一、编程规约

### 1.命名风格

#### 1.1.各层命名规约

1.获取单个对象用`get`做前缀

2.获取多个对象用`list`做前缀，复数形式结尾

3.获取统计值的方法用`count`做前缀

4.插入的方法用`save/insert`做前缀

5.删除的方法用`remove/delete`做前缀

6.修改的方法用`update`做前缀

### 2.常量定义

### 2.1.不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护

大而全的常量类，杂乱无章，使用查找功能才能定位到修改的常量，不利于理解和维护。

### 3.代码格式

#### 3.1.单行字符数限制不超过120个，超出需要换行，换行时遵循如下原则

1.第二行相对第一行缩进4个空格，从第三行开始，不再继续缩进；

2.运算符与下文一起换行；

3.方法调用的点符号与下文一起换行；

4.在多个参数超长，在逗号后换行；

5.在括号前，不要换行；

![换行示例](https://raw.githubusercontent.com/moon-xuans/mediaImage/master/2024/20240416205900.png)

### 4.OOP规约

#### 4.1.外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated注解，并清晰地说明采用的新接口或者新服务式什么

#### 4.2.Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals

推荐使用java.util.Objects#equals

#### 4.3.关于基本数据类型与包装数据类型的使用标准

1.所有的POJO类属性必须使用包装数据类型

2.RPC方法的返回值和参数必须使用包装数据类型

3.所有的局部变量使用基本数据类型

#### 4.4.定义DO/DTO/VO等POJO类时，不要设定任何属性默认值

#### 4.5.当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读，这条规则优先于下一条规则

#### 4.6.类内方法定义的顺序依次是：共有方法或保护方法 > 私有方法 > getter/setter方法

### 5.集合处理

#### 5.1.使用entrySet遍历Map类集合KV，而不是keySet方法进行遍历

keySet其实是遍历了2次，一次是转为Iterator对象，另一次是从hashMap中取出key所对应的value。而entrySet只是遍历了一次就把key和value放到了entry中，效率更高。如果是JDK8，使用Map.foreach方法。

### 6.并发处理

#### 6.1.线程资源必须通过线程池提供，不允许在应用中自行显示创建线程

使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题

#### 6.2.线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方法

#### 6.3.并发修改统一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用version作为更新依据。

如果每次方法冲突概率小于20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于3次。

#### 6.4.volatile解决多线程内存不可见的问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题

如果是count++操作，使用AtomicInteger count = new AtomicInteger();count.addAndGet(1);如果是JDK8，推荐使用LongAdder对象，比AtomicLong性能更好(减少乐观锁的重试次数)

### 7.控制语句

#### 7.1.在if/else/for/while/do语句中必须使用大括号。即使只有一行代码，避免采用单行的编码方法:if (condition) statements

#### 7.2.在高并发场景中，避免使用“等于”判断作为中断或者退出的条件

如果并发控制没有处理好，容易产生等值判断被“击穿”的情况，使用大于或小于的区间判断条件来代替。

#### 7.3.表达异常的分支时，少用if-else方法，这种方式可以改写成

```java
if (condition) {
    ...
    return obj;
}
```

超过3层的if-else的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句实例如下:

![卫语句示例](https://raw.githubusercontent.com/moon-xuans/mediaImage/master/2024/20240417200728.png)

#### 7.4.除常用方法(如getXxx/isXxx)等外，不要在条件判断中执行其他复杂的语句，将复杂逻辑判断的结果赋给一个有意义的布尔变量名，以提高可读性

![布尔结果示例](https://raw.githubusercontent.com/moon-xuans/mediaImage/master/2024/20240417201022.png)

#### 7.5.循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的try-catch操作(这个try-catch是否可以移至循环体外)

#### 7.6.避免采用取反逻辑运算符

取反逻辑不利于快速理解，并且取反写法必然存在对应的正向逻辑写法

### 8.注释规约

#### 8.1.所有类都必须添加创建者和创建日期

#### 8.2.所有的枚举类型字段必须要有注释，说明每个数据项的用途

#### 8.3.对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能理解当时的思路；注释也是给继任者看的，使其能够迅速接替自己的工作

#### 8.4.好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担

### 9.其他

#### 9.1.及时清理不再使用的代码段或配置信息

对于垃圾代码或过时配置，坚决清理干净，避免程序过度臃肿，代码冗余。

对于暂时被注释掉，后续可能恢复使用的代码片断，在注释代码上方，统一规定使用三个斜杠(///)来说明注释掉代码的理由。

## 二、异常日志

### 1.异常处理

#### 1.1.有try块放到了事务代码中，catch异常后，如果需要回滚事务，一定要注意手动回滚事务

#### 1.2.方法的返回值可以为null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回null值

#### 1.3.防止NPE，是程序员的基本修养，注意NPE产生的场景

1.返回类型为基本数据类型，return包装数据类型的对象时，自动拆箱有可能产生NPE。

```java
public int f() {
    return Integer对象
} 
如果为null，自动拆箱抛NPE
```

2.数据库的查询结果可能为null。

3.集合里的元素即使isNotEmpty,取出的元素有可能为null。

4.远程调用返回对象时，一律要求进行空指针判断，防止NPE。

5.对于Session中获取的数据，建议NPE检查，避免空指针。

6.级联调用obj.getA().getB().getC();一连串调用，易产生NPE。(使用JDK8的Optional类来防止NPE问题)

#### 1.4.避免出现重复的代码(Don't Repeat Yourself)，即DRY原则

随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是组件化。

## 二、日志规约

### 1.异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过throws往上抛出

### 2.可以使用warn日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。如非必要，请不要在此场景打出error级别，避免频繁报警

注意日志输出的级别，error级别只记录系统逻辑错误、异常或重要的错误信息。

### 3.尽量用英文来描述日志错误信息，如果日志中的错误信息用英文描述不清楚的话使用中文描述即可，否则容易产生歧义。国际化团队或海外部署的服务器由于字符集问题，使用全英文来注释和描述日志错误信息

## 三、单元测试

### 1.好的单元测试必须遵守AIR原则

单元测试在线上运行时，感觉像空气(AIR)一样并不存在，但在测试质量的保障上，却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复性的特点。

- A： Automic(自动化)
- I: Independent(独立性)
- R: Repeatable(可重复性)

### 2.单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，执行过程必须是完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。单元测试中不准使用System.out来进行人肉验证，必须使用assert来验证

### 3.保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后顺序

### 4.单元测试是可以重复执行的，不能受到外界环境的影响

单元测试通常会放到持续集成中，每次有代码check in时单元测试都会被执行。如果单测对外部环境(网络、服务、中间件等)有依赖，容易导致持续集成机制的不可用

### 5.对于单元测试，要保证测试粒度足够小，有助于精准定位问题。单测粒度至多是类级别，一般是方法级别

只有测试粒度小才能在出错时尽快定位到出错位置。单测不负责检查跨类或者跨系统的交互逻辑，那是集成测试的领域。

### 6.和数据库相关的单元测试，可以设定为自动回滚机制，不给数据库造成脏数据。或者对单元测试产生的数据有明确的前后缀标识

在RDC内部单元测试中，使用RDC_UNIT_TEST_的前缀标识数据。

### 7.对于不可测的代码建议做必要的重构，使代码变得可测，避免为了达到测试要求而书写不规范测试代码

## 四.MySQL数据库

### 1.建表规约

#### 1.1.表达是否概念的字段，必须使用is_xxx的方式命名，数据类型是unsigned tinyint(1表示是，0表示否)

任何字段如果是非负数，必须是unsigned。

POJO类中的任何布尔类型的变量，都不要加is前缀，所以，需要在< resultMap >设置从is_xxx到Xxx的映射关系。数据库表示是与否的值，使用tinyint类型，坚持is_xxx的命名方式是为了明确其取值含义与取值范围。

#### 1.2.表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重开率

MySQL在Windows下不区分大消息，但在Linux下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。

#### 1.3.表名不使用复数名词

表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于DO类名也是单数形式，符合表达习惯。

#### 1.4.禁用保留字，如desc、range、match、delayed等，请参考MySQL官方保留字

#### 1.5.主键索引名为pk_字段名；唯一索引名为uk_字段名；普通索引名则为idx_字段名

#### 1.6.小数类型为decimal，禁止使用float和double

float和double在存储的时候，存在精度损失的问题，很可能在值的比较时，得不到正确的结果。如果存储的数据范围超过decimal的范围，建议将数据拆成整数和小数分开存储。

#### 1.7.如果存储的字符串长度几乎相等，使用char定长字符串类型

#### 1.8.varchar是可变长字符串，不预先分配存储空间，长度不要超过5000，如果存储长度大于此值，定义字段类型为text，独立出现一张表，用主键来对应，避免影响其他字段索引效率

#### 1.9.表必备三字段：id，gmt_create，gmt_modified

其中id必为主键，类型为bigint unsigned、单表时自增、步长为1。gmt_create，gmt_modified的类型均为datetime类型，前者现在时表示主动创建，后者过去分词表示被动更新。

#### 1.10.表的命名最后是加上”业务名称_表的作用“

> 例: alipay_task/force_project/trade_config

#### 1.11.库名与应用名称尽量一致

#### 1.12.如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释

#### 1.13.字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循

1）不是频繁修改的字段

2）不是varchar超长字段，更不能是text字段。

> 例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。

#### 1.14.合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度

### 2、索引规约

#### 2.1.业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引

不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查询速度是明显的；另外，即使在应用层做了非常完善的校验机制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生

#### 2.2.超过三个表禁止join。需要join的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引

即使双表join也要注意表索引、SQL性能

#### 2.3.在varchar字段上建议索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可

#### 2.4.利用覆盖索引来进行查询操作，避免回表

如果一本书需要知道第11章是什么标题，会翻开第11章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。

能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效果，用explain的结果，extra列会出现：using index。

#### 2.5.创建索引时避免有如下极端误解

1.宁滥勿缺。认为一个查询就需要建一个索引。

2.宁缺毋滥。认为索引会消耗空间、严重拖慢更新和新增速度。

3.抵制唯一索引。认为业务的唯一性一律需要在应用层通过”先查后插“方式解决。

### 3、SQL语句

#### 3.1.不要使用count(列名)或count(常量)来替代count(*)，count(\*)是SQL92定义的标准统计行数的语法，跟数据库无关，跟NULL和非NULL无关

count(*)会统计之为NULL的行，而count(列名)不会统计此列为NULL值的行。

#### 3.2.count(distinct col)计算该列除NULL之外的不重复行数，注意count(distinct col1, distinct col2)如果其中一列全为NULL，那么即使另一列有不同的值，也返回为0

#### 3.3.当某一列的值全是NULL,count(col)的返回结果为0，但sum(col)的返回结果为NULL，因此使用sum()时需要注意NPE问题

可以使用如下方式来避免sum的NPE问题:SELECT IF(ISNULL(SIM(g)), 0, sum(g)) form table。

#### 3.4.在代码中写分页查询逻辑时，若count为0应直接返回，避免执行后面的分页语句

#### 3.5.不得使用外键与级联，一切外键概念必须在应用层解决

#### 3.6.数据订正(特别是删除、修改记录操作)时，要先select，避免出现误操作，确认无误才能执行更新语句

#### 3.7.in操作能避免则避免，若实在避免不了，需要仔细评估in后边的集合元素数量，控制在1000个以内

### 4、ORM映射

#### 4.1.在表查询中，一律不要使用*作为查询的字段列表，需要哪些字段必须明确写明

1.增加查询分析器解析成本

2.增加字段容易与resultMap配置不一致

3.无用字段增加网络消耗，尤其是text类型的字段

#### 4.2.POJO类的布尔属性不能加is，而数据库字段必须加is_，要求在resultMap中进行字段与属性之间的映射

#### 4.3.更新数据库表记录时，必须同时更新记录对应的gmt_modified字段值为当前时间

#### 4.4.不要写一个大二全的数据更新接口。传入为POJO类，不管是不是自己的目标更新字段，都进行update table set c1=value1,c2=value2,c3=value3;这是不对的。执行SQL时，不要更新无改动的字段，一是容易错；二是效率低；三是增加binlog存储

#### 4.5.@Transactional事务不要滥用。事务会影响数据库的QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等

## 六、工程结构

### 1.应用分层

#### 1.1.(分层异常处理规约)在DAO层，产生的异常类型有很多，无法用系列度的异常进行catch，使用catch(Exception e)方式，并throw new DAOException(e)，不需要打印日志，因为日志在Manager/Service一定需要捕获并打印到日志文件中去，如果同台服务器再打印日志，浪费性能和存储。在Service层出现异常时，必须记录出错日志到磁盘，尽可能带上参数信息，相当于保护案发现场。如果Manager层与Service同机部署，日志方式与DAO层处理一致，如果是单独部署，则采用与Service一致的处理方式。Web层绝不应该继续往上抛异常，因为已经处于顶层，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到友好错误页面，加上用户容易理解的错误提示信息。开放接口层要将异常处理成错误码和错误信息方式返回

#### 1.2.分层领域模型规约

- DO(Data Object): 此对象与数据库表结构意义对应，通过DAO层向上传输数据源对象。
- DTO(Data Transfer Object): 数据传输对象,Service或Manager向外传输的对象。
- BO(Business Object):业务对象，由Service层输出的封装业务逻辑的对象。
- AO(Application Object):应用对象，在Web层与Service层之间抽象的复用对象模型，极为贴近展示层，复用度不高。
- VO(View Object):显示层对象，通常是Web向模板渲染引擎层传输的对象。
- Query:数据查询对象，各层接收上层的查询对象。注意超过2个参数的查询封装，禁止使用Map类来传输。

### 2.二方库依赖

#### 2.1.定义GAV遵从以下原则

1.GroupID格式:com.{公司/BU}.业务线[.子业务线]，最多4级。

2.ArtifactID格式：产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下

3.Version:详情规定参考下方。

#### 2.2.二方库版本库命名方式：主版本号.次版本号.修订号

1.主版本号：产品方向改变，或者大规模API不兼容，或者架构不兼容升级。

2.次版本号：保持相对兼容性，增加主要功能特性，影响范围极小的API不兼容修改

3.修订号：保持完整兼容性，修复BUG、新增次要功能特性等。

注意起始版本号必须为：1.0.0，而不是0.0.1。正式发布的类库必须先去中央仓库进行查证，使版本号有延续性，正式版本号不允许覆盖升级。如当前版本：1.3.3，那么下一个合理的版本号：1.3.4或1.4.0或2.0.0

#### 2.3.线上引用不要依赖SNAPSHOT版本(安全包除外)

不依赖SNAPSHOT版本是保证应用发布的幂等性。另外，也可以加快编译时的打包构建

#### 2.4.为避免应用二方库的依赖冲突问题，二方库发布者应当遵循以下原则

1.精简可控原则。移除一切不必要的API的依赖，只包含Service API、必要的领域模型对象、Utils类、常量、枚举等。如果依赖其他二方库，尽量是provided引入，让二方库使用者去依赖具体版本号；无log具体实现，只依赖日志框架。

2.稳定可追溯原则。每个版本的变化应该被记录，二方库由谁维护，源码在哪里，都需要能方便查到。除非用户主动升级版本，否则公共二方库的行为不应该发生变化。

