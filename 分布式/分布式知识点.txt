一、一些场景问题
	1.本地一个事务，再远程服务调用的时候也有一个事务，可以放到一个事务里吗？能保证一致性吗？
		如果在本地事务中调用远程服务，那样本地该事务的操作就与提供远程服务的接口强依赖了，如果远程服务出现了问题，那么就会拖长事务，事务长时间没有提交，数据库连接池就不会被释放，随着太多的数据库连接被占用，可能会导致数据库崩溃。
	2.在编码中涉及两个应用进程调用最应该考虑哪三点？
		1.熔断降级(防止服务间雪崩)
		2.调用不明确或者失败场景的兜底方案(重试、补偿)
		3.配置相关告警规则(事中能及时感知)
二、CAP&BASE理论
	1.CAP理论
		简介:CAP也就是Consistency(一致性)、Availability(可用性)、Partition Tolerance(分区容错性)这三个单词首字母组合。
		
		CAP定理指出对于一个分布式系统来说，当设计读写操作时，只能同时满足以下三点中的两个:
			一致性:所有节点访问同一份最新的数据副本
			可用性:非故障的节点在合理的时间内返回合理的响应(不是错误或者超时的响应)
			分区容错性:分布式系统出现网络分区的时候，仍然能够对外提供服务。
		
		什么是网络分区？
			分布式系统中，多个节点之前的网络本来是连通的，但是因为某些故障(比如部分节点网络出了问题)某些节点之间不连通了，整个网络就分成了几块区域，这就叫网络分区。
			
		不是所谓的“3选2”
			大部分人解释这一定律时，常常简单的表述为:"一致性、可用性、分区容错性三者你只能达到其中两个，不可能同时达到"。实际上这是一个非常具有误导性质的说法。
				
				当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能2选1.也就是说当网络分区之后P是前提，决定了P之后才有C和A的选择。也就是说分区容错性我们是必须要实现的。
			因此，分布式系统理论上不可能选择CA架构，只能选择CP或者AP架构。比如ZooKeeper、HBase就是CP架构，Cassandra、Eureka就是AP架构，Nacos不仅支持CP架构也支持AP架构。
			
			为啥不可能选择CA架构呢？举个例子：若系统出现“分区”，系统中的某个节点在进行写操作。为了保证C，必须要禁止其他节点的读写操作，这就和A发生冲突了。如果为了保证A，其他节点的读写操作正常的话，那就和C发生冲突了。
			
			选择CP还是AP的关键在于当前的业务场景，没有定论，比如对于需要确保强一致性的场景如银行一般会选择保证CP。
			
			另外，需要补充说明的一点是：如果网络分区正常的话(系统在绝大部分时候所处的状态)，也就说不需要保证P的时候，C和A能够同时保证。
		CAP实际应用案例
			1.Zookeeper保证的是CP。任何时刻对ZooKeeper的读请求都能得到一致性的结果，但是，ZooKeeper不保证每次请求的可用性比如在Leader选举过程中或者半数以上的机器不可用的时候服务就是不可用的。
			2.Eureka保证的则是AP。Eureka在设计的时候就是优先保证A(可用性)。在Eureka中不存在什么Leader节点，每个节点都是一样的、平等的。因此Eureka不会像ZooKeeper那样选举过程中或者半数以上的机器不可用的时候服务就是不可用的情况。Eureka保证即使大部分节点挂掉也不会影响正常提供服务，只要有一个节点是可用的就行了。只不过这个节点上的数据可能并不是最新的。
			3.Nacos不仅支持CP也支持AP。
		总结
			在进行分布式系统设计和开发时，我们不应该仅仅局限在CAP问题上，还要关注系统的扩展性、可用性等等。
			
			在系统发生“分区”的情况下，CAP理论只能满足CP或者AP。要注意的是，这里的前提是系统发生了“分区”
			
			如果系统没有发生“分区”的话，节点间的网络连接通信正常的话，也就不存在P了。这个时候，我们就可以同时保证C和A了。
			
			总结：如果系统发生“分区”，我们要考虑选择CP还是AP。如果系统没有发生“分区”的话，我们要思考如何保证CA。
	2.BASE理论
		简介
			BASE是Basically Available(基本可用)、Soft-state(软状态)和Eventually Consistent(最终一致性)三个短语的缩写。BASE理论是对CAP中一致性C和可用性A权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的，它大大降低了我们对系统的要求。
		
		BASE理论的核心思想
			即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。
				也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体"主要可用"。
			BASE理论本质上是对CAP的延伸和补充，更具体地说，是对CAP中AP方案的一个补充。  
			
			为什么这样说呢？
			
			CAP理论这节我们也说过了:
				如果系统没有发生“分区”的话，节点间的网络连接通信正常的话，也就不存在P了。这个时候，我们就可以同时保证C和A了。因此，如果系统发生“分区”，我们要考虑CP还是AP，如果系统没有发生“分区”的话，我们要思考如何保证CA。
			因此，AP方案只是在系统发生分区的时候放弃一致性，而不是永远放弃一致性。在分区故障恢复后，系统应该达到最终一致性。这一点其实就是BASE理论延伸的地方。
		BASE理论三要素
			1.基本可用
				基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。
				
				什么叫允许损失部分可用性呢？
					a.响应时间上的损失：正常情况下，处理用户请求需要0.5s返回结果，但是由于系统出现故障，处理用户请求的事件变为3s。
					b.系统功能上的损失：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。
			2.软状态
				软状态指允许系统中的数据存在中间状态(CAP理论中的数据不一致)，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。
			3.最终一致性
				最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。
				
					分布式一致性的3种级别:
						1.强一致性：系统写入了什么，读出来的就是什么。
						2.弱一致性：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据时最新的，只是会尽量保证某个时刻达到数据一致的状态。
						3.最终一致性:弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。
						
						业界比较推崇是最终一致性级别，但是某些数据一致要求十分严格的场景比如银行转账还是要保证强一致性。
				那实现最终一致性的具体方式是什么呢？
					a.读时修复:在读取数据时，检测数据的不一致，进行修复。比如Cassandra的Read Repair实现，具体来说，在向Cassandra系统查询数据的时候，如果检测到不同节点的副本数据不一致，系统就自动修复数据。
					b.写时修复:在写入数据，检测数据不一致时，进行修复。比如Cassandra的Hinted Handoff实现。具体来说，Cassandra集群的节点之间远程写数据的时候，如果写失败就将数据缓存下来，然后定时重传，修复数据的不一致性。
					c.异步修复：这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。
					
					比较推荐写时修复，这种方式对性能消耗比较低。
		总结
			ACID是数据库事务完整性的理论，CAP是分布式系统设计理论，BASE是CAP理论中AP方案的延伸。
		
三、分布式理论
	1.RPC原理
		RPC的核心功能主要是这5部分构成:
			1.客户端(服务消费端)：调用远程方法的一端。
			2.客户端Stub(桩):这其实就是一代理类。代理类主要做的事情很简单，就是把你调用方法、类、方法参数等信息传递到服务端。
			3.网络传输：网络传输就是你要你调用的方法的信息比如说参数啊这些东西传输到服务端，然后服务端执行完之后再把返回结果通过网络传输给你传输回来。网络传输的实现方式有很多种比如最基本的Socket或者性能以及封装更加优秀的Netty(推荐).
			4.服务端Stub(桩):这个桩就不是代理类了。我觉得理解为桩实际不太好，大家注意一下就好。这里的服务端Stub实际指的就是接收到客户端执行方法的请求后，去指定对应的方法然后返回结果给客户端的类。
			5.服务端(服务提供端)：提供远程方法的一端。
		RPC的整个过程如下:
			1.服务消费端(client)以本地调用的方式调用远程服务
			2.客户端Stub(client stub)接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体(序列化):RpcRequest
			3.客户端Stub(client stub)：找到远程服务的地址，并将消息发送到服务提供端。
			4.服务端Stub(桩)收到消息将消息反序列化为Java对象:RpcRequest.
			5.服务端Stub(桩)根据RpcRequest中的类、方法、方法参数等信息调用本地的方法；
			6.服务端Stub(桩)得到方法执行结果并将组装成能够进行网络传输的消息体RpcResponse(序列化)发送至消费方；
			7.客户端Stub(client stub)接收到消息并将消息反序列化为java对象RpcResponse，这样也就得到了最终结果。
	2.既有HTTP，为啥用RPC进行服务调用？
		RPC只是一种设计而已
			RPC只是一种概念、一种设计，就是为了解决不同服务之间的调用问题，它一般会包含传输协议和序列化协议这两个。
			
			但是，HTTP是一种协议，RPC框架可以使用HTTP协议作为传输协议或者直接使用TCP作为传输协议，使用不同的协议一般也是为了适应不同的场景。
		RPC框架功能更齐全
			成熟的RPC框架还提供好了"服务自动注册与发现"、“智能负载均衡”、“可视化的服务治理和运维”、“运行期流量调度”等等功能，这些也算是选择RPC进行服务注册和发现的一方面原因吧！
			
		一个常见的错误观点
			很多文章中还会提到说HTTP协议相较于自定义TCP报文，增加的开销在于连接的建立与断开，但是这个观点已经被否认了，摘自知乎:
				首先要否认一点HTTP协议相较于自定义TCP报文协议，增加的开销在于连接的建立与断开。HTTP协议支持连接池复用的，也就是建立一定数量的连接不断开，并不会频繁的创建和销毁连接。二要说的是HTTP也可以使用Protobuf这种二进制编码协议对内容进行编码，因此二者最大的区别还是在传输协议上。
		

	
四、Dubbo
	1.Dubbo解决了什么问题？
		1.负载均衡:同一个服务部署在不同的机器时该调用哪一台机器上的服务。
		2.服务调用链路生成:随着系统的发展，服务越来越多，服务间依赖关系变得错综复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。Dubbo可以为我们解决服务之间互相是如何调用的。
		3.服务访问压力以及时长统计、资源调度和治理：基于访问压力实时管理集群容量，提高集群利用率。
		4.....
		
	2.说一次Dubbo服务请求流程？
		基本工作流程：
		1.provider，启动时，会把自己所有接口注册到注册中心，并订阅动态配置configurationors
		2.consumer，启动时，会去注册中心订阅自己需要的providers、configurators、routers
		3.Registry，订阅信息变更时，会推送订阅信息providers服务提供者列表、configurators、routers给消费者
		4.注册中心(Registry)，返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者
		4.消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
		5.monitor，服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。
		
		Dubbo的核心角色:
			a.Container:服务运行容器，负责加载、运行服务提供者。必须。
			b.Provider:暴露服务的服务提供方，会向注册中心注册自己提供的服务。必须。
			c.Consumer：调用远程服务的服务消费方，会向注册中心订阅自己所需的服务。必须。
			d.Registry:服务注册与发现的注册中心。注册中心会返回服务提供者地址列表给消费者。非必须。
			e:Monitor:统计服务的调用次数和调用时间的监控中心。服务消费方和提供者会定时发送统计数据到监控中心。非必须。
	
	3.说一下Dubbo工作原理
		工作原理分10层:
		第一层:service层，接口层，给服务提供者和消费者来实现的(留给开发人员来实现);
		第二层:config层，配置层，Dubbo相关的配置。支持代码配置，同时也支持基于 Spring 来做配置，以 ServiceConfig, ReferenceConfig 为中心
		第三层:Proxy层，调用远程方法像调用本地的方法一样简单的一个关键，真实调用过程依赖代理类，以 ServiceProxy 为中心。
		第四层：registry层，封装服务地址的注册与发现。
		第五层：cluster层，路由层，封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心。
		第六层：monitor层，监控层，RPC 调用次数和调用时间监控，以 Statistics 为中心；
		第七层：protocol层，封装 RPC 调用，以 Invocation, Result 为中心。
		第八层：exchange层，封装请求响应模式，同步转异步，以 Request, Response 为中心。
		第九层：transport层，抽象 mina 和 netty 为统一接口，以 Message 为中心。
		第十层：serialize层，对需要在网络传输的数据进行序列化。
		
	4.Dubbo中的Invoker概念了解吗？
		简单来说，Invoker就是Dubbo远程调用的对象。
		按照Dubbo官方的话来说，Invoker分为:
			服务提供Invoker
			服务消费Invoker
		假如我们需要调用一个远程方法，我们需要动态代理来屏蔽远程调用的细节吧！我们屏蔽掉的这些细节就依赖对应的Invoker实现，Invoker实现了真正的远程服务调用。
	
	5.Dubbo的SPI机制了解吗？
		SPI(Service Provider Interface)机制被大量用在开源项目中，它可以帮助我们动态寻找服务/功能(比如负载均衡策略)的实现。

		SPI 的具体原理是这样的：我们将接口的实现类放在配置文件中，我们在程序运行过程中读取配置文件，通过反射加载实现类。这样，我们可以在运行的时候，动态替换接口的实现类。和 IoC 的解耦思想是类似的。

		Java 本身就提供了 SPI 机制的实现。不过，Dubbo 没有直接用，而是对 Java原生的 SPI机制进行了增强，以便更好满足自己的需求。
	6.注册中心挂了，consumer还能不能调用provider？
		可以。因为刚开始初始化的时候，consumer会将需要的所有提供者的地址等信息拉取到本地缓存，所以注册中心挂了可以继续通信。但是provider挂了，那就没法调用了。
		
		关键：consumer本地缓存服务列表。
	7.怎么实现动态感知服务下线的呢？
	
		服务订阅通常有pull和push两种方式：
			pull模式需要客户端定时向注册中心拉取配置；
			push模式采用注册中心主动推送数据给客户端；
		
		Dubbo Zookeeper注册中心采用的是事件通知与客户端拉取方式。服务第一次订阅的时候将会拉取对应目录下全量数据，然后在订阅的节点注册一个watcher。一旦目录节点下发生任何数据变化，ZooKeeper将会通过watcher通知客户端。客户端接到通知，将会重新拉取该目录下的全量数据，并重新注册watcher。利用这个模式，Dubbo服务就可以做到服务的动态发现。
		注意：Zookeeper提供了”心跳检测“功能，它会定时向各个服务提供者发送一个请求(实际上建立的是一个socket长连接),如果长期没有响应，服务中心就认为该服务提供者已经"挂了"，并将其剔除。
	8.Dubbo负载均衡策略？
		a.随机(默认):随机来
		b.轮询:一个一个来
		c.活跃度:机器活跃度来负载,Dubbo 就认为谁的活跃数越少，谁的处理速度就越快，性能也越好，这样的话，我就优先把请求给活跃数少的服务提供者处理。如果有多个服务提供者的活跃数相等那么会在计算一次，重新比较。
		d.一致性hash:落到同一台机器上，Dubbo 为了避免数据倾斜问题（节点不够分散，大量请求落到同一节点），还引入了虚拟节点的概念。通过虚拟节点可以让节点更加分散，有效均衡各个节点的请求量。
	
	9.Dubbo动态代理策略有哪些？
		默认使用javassist动态字节码生成，创建代理类，但是可以通过SPI扩展机制配置自己的动态代理策略。
	
	10.Dubbo支持哪些协议？
		dubbo协议，http协议，Memcached协议、Redis协议、Rest协议
	11.Dubbo支持哪些序列化方式？
		Dubbo支持多种序列化方式:JDK自带的序列化、hessian2、JSON、Kryo、FST、Protostuff、ProtoBuf等等。
		
		Dubbo默认使用的序列化方式是hession2.
		
		一般我们不会直接使用JDK自带的序列化方式。主要原因有两个:
			1.不支持跨语言调用:如果调用的是其他语言开发的服务的时候就不支持了。
			2.性能差:相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。
		
		Kyro和FST这两种序列化方式是Dubbo后来才引入的，性能非常好。不过，这两者都是专门针对Java语言的。
	12.说一下Dubbo与SpringCloud的区别？
		其实他们之间没什么关联之处，但是硬要问区别，那只能随便说说了。
		
		回答的时候主要围绕四个关键点来说：通信方式、注册中心、监控、断路器，其余像spring分布式配置、服务网关肯定得知道。
		
		通信方式
			Dubbo使用的是RPC通信；Spring Cloud使用的是 HTTP Restful方式。
		注册中心	
			Dubbo使用Zookeeper(官方推荐),还有Redis、Simple注册中心，但是不推荐；
			Spring Cloud使用的是 Spring Cloud Netflix Eureka。
		监控
			Dubbo使用的是Dubbo-monitor;Spring Cloud使用的是Spring Boot admin。
		断路器
			Dubbo在断路器这方面还不完善，Spring Cloud使用的是Spring Cloud Netflix Hystrix。
		分布式配置、网关服务、服务追踪、消息总线、批量任务等；
			Dubbo目前可以说还是空白，而Spring Cloud都有相应的组件来支撑。
			
---------------------------------------------------------------------------------------------------------------------------------------
				
	13.Zookeeper和Dubbo的关系？
		Zookeeper的作用
			zookeeper用来注册服务和进行负载均衡，哪一个服务由哪一个机器来提供必需让调用者知道，简单来说就是ip地址和服务名称的对应关系。当然也可以通过硬编码的方式把这种对应关系在调用方业务代码中实现，但是如果提供服务的机器挂掉调用者无法知晓，如果不更改代码会继续请求挂掉的机器提供服务。ZooKeeper通过心跳机制可以检测挂掉的机器并将挂掉机器的ip和服务对应关系从列表中删除。至于支持高并发，简单来说就是横向扩展，在不更改代码的情况通过添加机器来提高运算能力。通过添加新的机器向Zookeeper注册服务，服务的提供者多了能服务的客户就多了。
		Dubbo
			是管理中间层的工具，在业务层到数据仓库间有非常多服务接入和服务提供者需要调度，dubbo提供一个框架解决这个问题。注意这里的dubbo只是一个框架，至于你架子上放什么是完全取决于你的，就像一个汽车骨架，你需要配你的轮子引擎。这个框架中要完成调度必须要有一个分布式的注册中心，存储所有服务的元数据，可以用zk，也可以用的，只是大部分都在用zk。
		Zookeeper和dubbo的关系
			Dubbo的将注册中心进行抽象，它可以外接不同的存储媒介给注册中心提供服务，有Zookeeper，Memcached，Redis等。
			
			引入了Zookeeper作为存储媒介，也就把Zookeeper的特性引进来。首先是负载均衡，单注册中心的承载能力是有限的，在流量达到一定程度的时候就需要分流，负载均衡就是为了分流而存在的，一个Zookeeper群配合相应的Web应用就可以容易达到负载均衡；资源同步，单单有负载均衡还不够，节点之间的数据和资源需要同步，Zookeeper集群就天然具备有这样的功能；命名服务，将树状结构用于维护全局的服务地址列表，服务提供者在启动的时候，向Zookeeper上的指定节点/dubbo/${serviceName}/providers目录下写入自己的URL地址，这个操作就完成了服务的发布。其他特性还有Mast选举，分布式锁等。

	14.Dubbo容错策略
		failover cluster模式
			provider宕机重试以后，请求会分到其他的provider上，默认两次，可以手动设置重试次数，建议把写操作重试次数设置成0.
		failback模式
			失败自动恢复会在调用失败后，返回一个空结果给服务消费者。并通过定时任务对失败的调用进行重试，适合执行消息通知等操作。
		failfast cluster模式
			快速失败只会进行一次调用，失败后立即抛出异常。适用于幂等性、写操作，类似于failover cluster模式中重试次数设置为0的情况。
		failsafe cluster模式
			失败安全是指，当调用过程中出现异常时，仅会打印异常，而不会抛出异常。适用于写入审计日志等操作。
		forkling cluster模式
			并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过forks="2"来设置最大并行数。
		broadcast cluster模式
			广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。