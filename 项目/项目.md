

# 项目
## 1.项目介绍

首先，我们这个项目是去年暑假在指导老师的带领下，和工作室其他成员合作完成的一个笔迹分析项目。这个项目的主要作用是根据用户上传的笔迹图片，进行图片预处理以及笔迹特征的提取，笔迹特征包括：像素数，标题字体大小、字间距、倾斜度，字面积、行间距、占用率、横竖撇捺长度和倾斜程度、高宽比、留白等23种笔迹特征，将这些笔迹特征以及用户信息生成word文档，图片和文档存放oss上，并且可以通过上传jar包的方式热替换预处理算法。

项目结构上是采用自实现的spring mvc、ioc容器和mybatis，通过xml的方式使得代码和配置进行解耦，并通过每个类提供一个入口来调用类的私有方法的手段，来保证对象方法的私有性，考虑到项目角色权限的复杂度，因此采用RBAC的权限模型，实现了权限管理。

通过提取的笔迹特征，有多种使用价值:

- 司法领域上，可以通过笔迹特征的比较，得到一个笔迹的相似度，来判断是否是同一个人的书写。
- 在心理学领域上，可以通过笔迹特征和性格之间的关系，来分析出此人的性格，这个本来也是我们要实现的功能之一，不过参考了国内外的论文，无法准确得到笔记特征和性格的关系，因此没做相应的实现。
- 在教育领域上，可以通过笔迹特征以及一些正规字体的比较，可以给出书写人字体的改进建议。

因此，我觉得这个项目在以后有很大的发展前景，可以提供笔迹特征的数据应用于各个领域，并且可以结合用户的信息，做一些大数据方面的统计。

如果问到这里，对应的功能实现了吗，那就说这个项目只是个采集提取系统。



笔迹特征包括:像素数、标题字体大小、平均字面积、最小字面积、最大字面积、平均行间距、标题字间距、最小行间距、最大行间距、标题倾斜度、占用率、标首距、均匀程度比、横长、竖长、撇长、捺长、倾斜程度、竖倾程度、捺倾斜度、平均高宽比、最小高宽比、最大高宽比、标题高宽比、页眉留白、页脚留白、左侧留白、右侧留白23种笔迹特征。

## 2.项目流程

ioc容器是负责baseurl和实例的关系，然后还存储了url到methodname的关系，调用的时候通过className通过switch到对应类的XXXService的execute方法中，通过ioc的容器获取到对应的实例，并通过url获取到对应的methodname，然后也是通过switch进行方法的调用（这样做的原因是：避免将方法public暴露出来，所有的方法只有类中的一个入口方法进行调用，保证了方法的私有性以及对象的封装），找到private的方法后，通过Execute.execute进行dao层的方法调用，里面会传入mappername和methodname进行方法的确定，并且会传入参数，返回类型直接强转即可。



这边，spring的ioc容器设计的时候，考虑到项目的内容，大多数的使用，都是一些Component类的调用，比如Service等等，由于这里面并没有一些类变量，不需要考虑类变量的变化，因此这些Service是线程安全的，直接使用单例模式即可，类似于spring的ioc，scope为Singleton的情况下，将所有id对应的对象实例存放在一个map中，避免service的多次重复生成，消耗性能。



我们项目中，无论是service或者mapper都是直接采用xml的方式进行管理的，因为通过xml管理有一些好处:

- xml是集中式的元数据，不需要和代码绑定的；
- 使用xml配置可以让软件更具有扩展性，如果说是要修改url和对象实例的对象关系的时候，只需要修改xml的配置即可。
- 对象之间的关系一目了然。
- xml的最大优势在于，我们可以给项目量身定做一些使用的标记，使得xml更通俗易懂。
- 成熟的校验机制，来保证正确。可以使用Schema或者是DTD来对xml的正确性进行校验。
- 基于xml配置的时候，只需要修改xml即可，不需要对现有的程序进行修改。
- 容易与其他系统进行数据交互。数据共享方便。

当然，我们这里使用xml的主要目的是为了方便管理



缺点的话:

- 解析xml的时候必然会占用资源，势必会影响到应用程序的性能。

### 1.1.项目启动

将xml中的配置文件进行加载，一开始就全部实例化到ioc容器中，等待后续的调用。

![image-20220331161415923](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220331161415923.png)

![image-20220331161659907](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220331161659907.png)

![image-20220331161856860](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220331161856860.png)

### 1.2.处理请求

无论是get请求还是post请求都会调用到get请求，首先会经过beforeDispatch方法做一些前置处理

![image-20220331162259825](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220331162259825.png)

![image-20220331162927807](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220331162927807.png)

![image-20220331163151611](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220331163151611.png)

![image-20220331163907502](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220331163907502.png)

![image-20220331164036556](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220331164036556.png)

![image-20220331164525405](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220331164525405.png)

![image-20220331164552435](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220331164552435.png)

#### 1.2.1.为什么方法都是私有的？

根据迪米特法则，如果两个类之间没有直接关系，就应该通过第三者来进行调用，来保证他们的低耦合。

屏蔽内部细节，向外提过统一的入口，方便层次之间的调用。

因此，也可以使得大型项目整合其他系统的时候 方便接口调用。

## 3.项目重难点

### 3.1.实现在线上传算法jar包及反射实现算法的动态切换和调用

![image-20220228203822442](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220228203822442.png)

首先用户可以通过以上传jar包的形式，上传至lib包下，并将jar包路径保存到数据中。

在使用处理算法的时候，如果不指定的话，会使用项目的默认算法，但是如果指定的话，可以它是会根据指定路径获取文件。然后通过url类加载器加载去加载那个具体做处理的类，那个urlClassLoader事实上已经实现了动态切换，然后加载那个类，进行实例化后，通过反射去调用方法，最后返回结果。

热部署的原因是：它每次进行图片处理的时候，都会经过这个方法，判断它指定了哪个算法。

### 3.2.完成对图片的预处理和基于投影提取笔迹特征的提取算法

#### 3.2.1.预处理算法

![image-20220228212116562](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220228212116562.png)

##### 3.2.1.1.grayImage

![image-20220228212154712](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220228212154712.png)

灰度化，即把彩色图片灰度化便于后续对图片的处理

##### 2.2.1.2.binaryImageWithSW

![image-20220228212244623](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20220228212244623.png)

二值化，即把灰度化图片经过二值化变成只有黑白(只有0,1的矩阵)的数据，便于后续对图片的处理

##### 2.2.1.3.denoise

![image-20220228212321753](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220228212321753.png)

降噪（领域检测法），针对二值化后的图片来说(白底黑字)，噪点就是图片中一堆密集黑色像素点中少许白色像素点(字体里的白点或背景里的黑点)，这时，解决方法可以遍历像素点，一个像素点周围有8个像素点，如果这个像素点周围有6个以上像素点是黑色就可以把这个像素点也认为是黑色

#### 2.2.2.提取算法

x轴，y轴，投影上去

### 3.3.基于RBAC的权限管理

Role-Based Access,基于角色的访问控制。

采用Role、User、Permission以及两张中间表的设计，用户->角色，角色->权限。

在后端做了一个filter进行权限拦截，基于角色的一个权限管理，在用户登录成功之后，会把用户信息存到redis里面，包括用户的角色信息、封禁情况。

前端主要是做页面跳转的控制，后端是做权限请求的控制。

如果用户权限发生变化的话，那么首先会更新数据库，然后再删除缓存，再调用用户获取权限的方法，前端刷新页面，让他重新访问，此时缓存中没有，那么就会重新登录。


## 4.使用到的设计模式

### 4.1.模板方法

自实现的mybatis中有一个BaseExecutor的抽象模板类，在该类中实现了一级缓存，并通过继承的方式延迟到子类(在SimpleExecutor、ReuseExecutor、BatchExecutor)中，使得子类可以在不改变算法框架及其流程的前提下重新定义该算法在某些特定环节的实现，实现了父类代码复用，及子类方法扩展而不影响算法的稳定性。

![image-20220401231320516](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220401231320516.png)

![](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220401193519316.png)

![image-20220401231336780](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220401231336780.png)

### 4.2.责任链模式

自实现的mybaits中二级缓存使用到了责任链模式，通过将责任链将处理的操作成为链式，进行处理，将请求的发送与处理进行解耦。

![在这里插入图片描述](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/8ab53098bcf14296b9655a777ac8e937.png)

自实现mybatis中处理流程中，也是使用到了责任链，在实例化Executor、ParameterHandler、ResultSetHandler、StatementHandler这4个对象时，把这4个对象植入责任链中，然后用处理类对这些对象做一些操作。

![image-20220401202304548](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220401202304548.png)

### 4.3.单例模式

项目中在读取service.xml使用到的实例都是单例的，因为这里不涉及到实例的属性变化，所以使用单例模式创建。

这里的单例是饿汉式单例，因此天生是安全的，可以直接用于多线程而不会出现问题。

![image-20220331161856860](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220331161856860.png)

### 4.4.工厂模式

自实现的mybatis中SqlSessionFactory使用的是工厂模式，该工厂没有那么复杂的逻辑，是一个简单工厂模式。工厂模式将对象的创建和使用分离开来，并且可以使同一个类的构造函数，以不同的工厂创造出来，使用起来更加简单易懂。

![image-20220401204520460](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220401204520460.png)

### 4.5.装饰者模式

自实现的mybaits的二级缓存CachingExecutor使用到了装饰者模式，在原有的BaseExecutor的实现类下，通过装饰者模式扩展了功能。装饰者模式无须改变原有类及类的继承关系，动态扩展一个类的功能。它通过装饰者模式包装真实的对象(将被包装类作为包装类的成员变量)，并动态的向对象中添加或者撤销功能。

![image-20220401215213902](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220401215213902.png)

### 4.6.代理模式

自实现的mybatis中的核心应该就是代理模式，由于这个模式，只需要编写mapper的接口和sql语句，不需要考虑实现，交给mybatis生成代理对象进行完成具体的实现。

主要是分为两步，一是提前创建一个Proxy，二是使用的时候会自动请求Proxy，交给Proxy来执行具体操作。当使用Configuration的getMapper方法时，会调用MapperRegistry.getMapper方法，而该方法又会调用mapperProxyFactory.newInstance(sqlSession)来生成一个具体的代理对象mapperProxy对象，然后mapperProxy类实现了InvocationHandler接口，并且实现了该接口的invoke方法，进行后续的调用。

![image-20220401220832599](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220401220832599.png)

![image-20220401220856802](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220401220856802.png)

![image-20220401220921182](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220401220921182.png)

![image-20220401221010792](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220401221010792.png)

![image-20220401221116412](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220401221116412.png)



## 5.自实现mybatis的不同

### 5.1.处理流程

这里，mybatis的设计的时候，并不是按照原生mybatis的接口对应xml，创建代理对象的方式进行调用。而是只是使用到了xml做一些sql及返回类型和参数的设置。这里没有使用接口的原因：是为了避免XXXMapper的方法，直接public暴露出来，在service层调用dao层的时候，层与层之间耦合太高，并且不能体现出面向对象的封装特性，因此只需要传入MapperName和MapperMethodName进行调用Execute.execute()即可。

### 5.2.数据库连接池

数据库连接池底层用的jdbc，初始大小为3，扩容为5，最大为50(因为mysql最大连接是100)，连接用CopyOnWriteArrayList存储。

1.每个连接都有一个Connection，一个 boolean isBusy=false;默认为false表示闲着

2.要操作数据库获取连接的时候，遍历CopyOnWriteArrayList，如果有isBusy为false的就对该连接测试，则用conn.setAutoCommit()，如果不抛异常的话则说明该连接可用，将busy改为true，跳出循环返回该连接PooledConnection，否则就把这个连接移除掉，重新遍历。

如果没有为false的当前Vector中没有超过最大连接数就按扩容创建一些连接放入CopyOnWriteArrayList中再从CopyOnWriteArrayList中获取一个可用连接。



改进：原生的mybatis它是用synchronized(state)整个对象，因为原生的有idleConnections和activeConnections，因此要保证两个列表至今的一个原子性。我们这边为了提升效率，只使用了一个CopyOnWriteArrayList的Connections，来保证线程安全。



CopyOnWriteArrayList(免锁容器)的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛ConcurrentModificationException。在CopyOnWriteArrayList 中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。

- 由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者 full gc；

- 不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个 set操作后，读取到数据可能还是旧的,虽然 CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求；

**CopyOnWriteArrayList 透露的思想**

1、读写分离，读和写分开

2、最终一致性

3、使用另外开辟空间的思路，来解决并发冲突

### 5.3.一级缓存和二级缓存

#### 5.3.1.一级缓存

我们这边的一级缓存为了保证操作的安全性，因为没有引入SqlSessionManager，因此将HashMap改成了ConcurrentHashMap。

首先，要知道原生的mybatis的DefaultSqlSession这个类不是线程安全的，因此要保证HashMap的读写的线程安全，使用到了ConcurrentHashMap.

#### 5.3.2.二级缓存

二级缓存这里仍然是使用HashMap来作为存储的，这里为了解决二级缓存的线程安全。使用到了装饰器模式，对原有的HashMap的存储，方法上加了synchronized来保证它的一个线程安全。

## 6.项目收获

在这个项目中，首先，参与了项目的整个流程，包括需求分析、用例设计、数据库表的设计、前端UI的设计、后端框架的设计、前后端编码的实现，在每一个部分都做了相应的需求文档记录，需求分析和用例设计经过了多版本的迭代，整个过程中，我们会定期开会，进行讨论，提高了团队之间的合作性以及交流能力。在后期的编码实现阶段，首先做了后端框架的设计，自实现mybatis和ioc，提高了自己的阅读源码能力以及代码实现能力。业务功能实现阶段，编码之前进行了接口文档的编写，后期的代码实现全都严格按照接口文档进行编码，代码实现过程中，统一了编码规范。因此，我认为在这个项目过程中，对自己的整体实力有了很大的提高，参与了整个项目的流程，自己也能适应开发环境，有着良好的编码习惯，所以我觉得自己能够很好的适应工作环境。