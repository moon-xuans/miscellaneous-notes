一.八股文
	1.mybaits中#{}和${}的区别
		1.将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。
		2.将传入的数据直接显示生成在sql中。
		3.#方式能够很大程度防止sql注入。
		4.$方式无法防止sql注入。
		5.$方式一般用于传入数据库对象，例如传入表名。
		6.一般能用#的就别用$。
		7.mybatis排序时使用order by 动态参数时需要注意，用$而不是#
	2.mybatis和ibatis的区别
		1.Mybatis实现了接口绑定，使用更加方便。
			在ibatis2.x中我们需要在DAO的实现类中指定具体对应哪个xml映射文件
			而mybaits实现了DAO接口与xml映射文件的绑定，自动为我们生成接口的具体实现。
		2.对象关系映射的改进，效率更高
			对于对象间的映射关系，mybaits更加智能
		3.mybatis采用功能强大的基于OGNL的表达式来消除其他元素。
			mybatis采用OGNL表达式简化了配置文件的复杂性，使用起来更简洁。
	3.mybatis是如何进行分页的？分页插件的原理是什么？
		Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页。可以在sql内直接拼写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页，比如：MySQL数据的功能，在原有SQL后面拼写limit。
		
		分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，添加对应的物理分页语句和物理分页参数。

二.一级缓存
	1.作用:
		在同一个会话里面，多次执行相同的sql语句（statementId,参数,rowBounds完全相同）,会直接从内存取到缓存的结果，不会再发送到数据库与数据库交互。但是不同的会话里面，即使执行的sql一模一样，也不能使用到一级缓存。
	2.和会话的关系:
		Mybatis的一级缓存是会话层面进行缓存的。因此在SqlSession的实现类DefaultSqlSession中有一个configuration和一个executor，由于configuration是全局的，与缓存的作用范围不符，因此那缓存肯定是跟executor属性有关系。创建DefaultSqlSession的时候，会创建executor执行器，而所有的执行器的父类都是baseExecutor，因此可以猜测一级缓存是baseExecutor的一个属性，通过查看源码可以发现里面正好有一个PertualCache，它其实就是一个map集合。
		
		因此SqlSession对象持有了executor属性，而executor持有了一级缓存。
	3.生命周期:
		1.当会话结束时，SqlSession对象及其内部的Executor对象还有Cache对象也一并释放掉。
		2.如果SqlSession调用了close（）方法，会释放掉一级缓存Cache对象，一级缓存将不可用；
		3.如果SqlSession调用了clearCache()，会清空Cache对象中的数据，但是该对象仍可使用;
		4.SqlSession中执行了任何一个update操作(update()、delete()、insert())，都会清空Cache对象的数据，但是该对象可以继续使用。
	4.执行流程
		缓存执行的大概思路与我们熟知的缓存思想一致。
		1.对于某个查询，根据statementId,params,rowBounds来构建一个key值，根据这个key值去缓存Cache取出对应的key值存储的缓存结果
		2.判断Cache中根据特定的key值取的数据是否为空，即是否命中；
		3.如果命中，则直接将缓存结果返回；
		4.如果没命中：
		去数据库中查询数据，得到查询结果；
			a.将key和查询的记过分别作为key，value对存储到Cache中
			b.将查询结果返回;
	5.总结
		sqlSession持有BaseExecutor,BaseExecutor持有了一级缓存，查询时调用BaseExecutor的query()方法，并在query()方法中完成了一级缓存的功能。
		缓存查到了就返回查询结果，查询不到就调用queryFromDatabase()方法，然后queryFromDatabase()方法中调用doQuery()方法从数据库中查询数据，然后放入一级缓存，其中doQuery()方法是抽象的,需要BaseExecutor的不同类型子类具体实现。
三.二级缓存
	1.结构关系二级缓存是用来解决一级缓存不能跨会话共享的问题，范围是namespace级别,可以被多个sqlSession(会话)共享，生命周期和应用同步。默认关闭。
	
	Mybatis查询数据的顺序是:二级缓存 -> 一级缓存 -> 数据库。
	
	按照这种执行顺序设计来思考，一级缓存已经利用BaseExecutor完成了自身功能的实现，那么二级缓存要加在哪里进行维护，才合适呢？实际上Mybatis这里用了一个设计模式–装饰器模式来维护二级缓存，实现这个功能的类就是CachingExecutor(缓存执行器)。
	
	具体做法:
		Mybatis让CachingExecutor对BaseExecutor进行了包装。CachingExecutor中不仅要实现了二级缓存的功能，同时也要持有一个基础执行器(BaseExecutor)。当查询请求来临的时候，CachingExecutor会先判断二级缓存是否有缓存结果，如果有就直接返回，如果没有则委派给自己持有的BaseExecutor实现类，比如SimpleExecutor(简单执行器)来执行查询，这样就顺理成章的从二级缓存过渡到了一级缓存的执行流程了。最后会把得到的结果缓存起来，并且返回给用户。
	2.总结:
		SqlSession持有CachingExecutor,CachingExecutor来完成二级缓存的功能实现，并且持有BaseExecutor，在二级缓存开启并且查不到数据时（或者二级缓存本身没有开启），都会委派给BaseExecutor来执行查询。
	3.配置文件
		配置文件中有一个readOnly属性，如果要使用的话，必须保证查询出来的缓存实体类实现序列化接口。
		
		这是因为二级缓存为了保证读写安全，开启了序列化功能，缓存中保存的不再是查询出的对象本身，而是查询出的对象进行序列化后的字节序列，在获取数据的时候，又会把存好的字节序列进行反序列化，克隆出新对象，进行返回。
	4.二级缓存组件结构
		Mybatis的二级缓存要实现的功能更加复杂，比如：线程安全，过期清理，命中率统计，序列化….
		
		Mybatis为了尽可能的职责分明的实现这些复杂逻辑，在这里使用了一种设计模式：装饰者+责任链（变种），对二级缓存的功能组件进行设计。至于为什么说是一个责任链变种，我们需要先了解以下经典责任链的定义。
		责任链（经典定义）是一个请求有多个对象来处理，这些对象是一条链，但具体是由哪个对象来处理，根据条件来判断，如果不能处理会传递给该链的下一个对象，直到有对象处理它为止。
		而责任链中的链，是如何形成的呢？举一个例子，比如我们的链式结构是a对象->b对象->c对象，那我们就让a对象持有b对象，b对象持有c对象。从a对象开始，a对象的方法中可以调用b对象的方法，而b对象的方法中也可以调用c对象的方法，通过这样的方式，便形成了一条责任链。
		经典责任链的方式，要根据条件判断，虽然也许会经过链条上的很多对象，但最终只有一个对象真正对请求进行了处理，其他对象仅仅完成了向下传递，也要完成自己的功能实现。所以说Mybatis使用的是责任链的变种形式。
		最上层是SynchronizedCache，持有了一个名为delegate的LoggingCache类型对象，以此类推，直到链条上的最后一个Cache的实现类–PerpetualCache。而PerpetualCache本身持有了一个HashMap，这才是二级缓存数据的真正存放地（缓存区）。
		以查询为例，在调用二级缓存的getObject()方法的时候，就会从链条的起始端，比如SynchronizedCahce，开始调用自己特有的职能，另一个是调用链条上的下一个Cache实现类的getObject()方法，直到链条的尾端，比如PerpetualCache。调用链虽然复杂，但是每个实现类都是完成自己特有的附加功能，而最终真正完成数据存储工作的只有PerpetualCache这个类。
	5.事务缓存管理器
		1.结构:
			二级缓存是可以跨会话的。
			会话1首先进行了修改操作，然后进行了查询操作，并且把查询后就把查到的结果放入缓存中，而此时会话2也进行了查询操作，就会查到缓存中的结果直接返回，尴尬的是会话1最终没有提交事务，选择了回滚。这样就造成了会话2读到的数据不准确，读到了会话1未提交的数据，产生了脏读。
			所以Mybatis的二级缓存在设计时针对这样的情况，引入了事务缓存管理器。在事务缓存管理器中，维护了一个本地暂存区（会话范围内可见），本地暂存区又指向真正的缓存区（跨会话）。在进行查询操作的时候，会到缓存区中查看是否命中。如果没有命中，查询数据库得到数据后，仅仅把查询的结果放入暂存区，在提交事务的时候才要把暂存区中的数据刷新到缓存区。如果发生了回滚，则清空本地暂存区缓存的数据，不会刷新到缓存区，这样一来就避免了脏读的产生。
			
			每个CachingExecutor对应一个事务缓存管理器，通过前面的我们知道，每个会话中持有一个CachingExecutor（缓存执行器）。所以每个会话都有自己单独的事务缓存管理器。
			事务缓存管理器中维护了一个HashMap，这个HashMap便是暂存区的集合，而且这个map的key是cache（缓存区），所以每一个缓存区都有相应的暂存区（TransactionalCache），放在map中作为键值对被事务缓存管理器所维护，因为每个会话都有自己单独的事务缓存管理器，作为管理器属性集合中的一个对象—暂存区也只是会话可见的。
			接下来看一下代表暂存区的TransactionalCache，可以看见其中也维护了一个Map，这个map是暂存区真正用来暂存数据的地方，而delegate属性，代表的便是真正缓存区（刚刚介绍过的，Cache的实现类组成的责任链，完成了缓存区的维护），有了与缓存区之间的关联，在提交事务的时候，就可以方便的把暂存区的数据刷新到缓存区了。
		2.查询：
			如果使用到二级缓存，在查询时，会调用二级缓存的query方法。这里主要看其中的tcm.getObject(cache,key)和tcm.putObject(cache,key,list)方法，一个是通过事务缓存管理器取数据的方法，一个是通过事务管理器放入数据的方法。
			1)tcm.getObject(cache,key)—>取出数据
				在CachingExecutor的query()方法中，先是调用了事务缓存管理器的getObject(cache,key)方法。可以看见TransactionalCacheManager在处理getObject()的时候先调用了getTransactionalCache(),从map集合中取出当前缓存区对应的TransactionalCache(暂存区)，暂存区如果不存在，则创建一个新的暂存区对象存入map，然后调用获得的TransactionCache的getObject()方法。
				
				在TransactionalCache的getObject()方法中，直接调用了其指向的缓存区的getObject()方法，说明二级缓存在获取数据的时候会直接去缓存区（跨会话）取数据。

				而在clearOnCommit这个布尔值为true的时候，即使缓存区命中数据也只能返回null，这是因为，只有在有更新操作且未提交的时候clearOnCommit才是true，这种状态对于当前会话当前事务来说，缓存区的数据已经不准确了，所以最好的选择是重新查询数据库。
			2)tcm.putObject(cache,key,list)—>放入数据
				在query()方法中，没有从缓存区中取到数据，而重新查询了数据的情况下，就要调用tcm.putObject(),通过事务管理器设置数据到缓存。与getObject()一样，TransactionalCacheManager的putObject()方法也要先调用getTransactionalCache()获得TransactionalCache(暂存区)，然后调用TransactionalCache的putObject()方法。
		3.提交
			在提交的方法中，我们会把暂存区中的所有内容刷新到缓存区中。
			在我们调用sqlSession.commit()方法的时候，也会调用当前会话持有的缓存执行器的commit()方法，缓存执行器会执行事务缓存管理器的commit()方法。看一下事务缓存管理器的提交的源码，在事务缓存管理器的commit()方法，会调用事务缓存管理器所有暂存区(TransactionalCache)的commit()方法。
			
			在TransactionalCache的commit()方法中，如果有未提交的更新操作（clearOnCommit为true），则要清空缓存区，因为更新后，缓存区的数据便是不准确的了。随后调用flushPendingEntries()和reset()两个方法，flushPendingEntries()方法负责把所有暂存区的内容刷新到缓存中。而reset()方法则负责把本地暂存区清空，同时把clearOnCommit置为false。
		4.更新
			在缓存执行器调用更新操作的时候，会调用flushCacheIfRequired(),这个方法中会先判断ms.isFlushCacheRequired()，为true并且二级缓存存在就会执行事务缓存执行器的clear()方法，而isFlushCachingRequired()就是从标签里面取到的flushCache的值。而增删改操作的flushCache属性默认为true。所以进行更新的时候，也会调用事务缓存管理器的clear方法。
			
			在TransactionalCacheManager的clear方法中。依然是先获取暂存区，并调用暂存区的clear()方法。
			
			TransactionalCache的clear()方法中，clearOnCommit属性被置为了true，并清空了暂存区。清空暂存区不难理解，因为如果存在更新操作，则暂存区暂存起来的数据则有可能不再准确了。并且缓存区也定然出现了不一致的情况，所以在TransactionalCache的commit方法中，会去判断clearOnCommit是否为true(即是否进行过更新操作)，如果是，缓存区的数据也会被clear()掉。而在清除执行完成后，reset()方法中会把clearOnCommit重新置为false。
	4.总结
		Mybatis使用了装饰者+责任链（变种）的模式构建了二级缓存的组件，每一个功能都有相应的Cache实现类来完成，同时这些实现类也会调用自己持有的Cache实现类，完成责任链。最终被调用的类是PerpetualCache，它就是最终负责数据存储的类。
		而为了解决二级缓存跨会话使用可能引起的脏读问题，mybatis引入了事务缓存管理器，每一个会话持有一个事务缓存管理器，每个事务缓存管理器维护着多个缓存区（每个namespace都有对应的缓存区）对应的暂存区，暂存区中维护本地暂存数据，并指向它所属的缓存区。
		通过事务缓存管理器查询的时候，直接去查缓存区，但是如果没有命中，重新查询出的数据仅放入暂存区，直到进提交，才把数据刷新到缓存区。这是为了防止其他会话查到当前会话中的事务未提交的数据。而在执行更新操作的时候，会先清空对应的暂存区数据，在提交事务的时候，也会把对应的缓存区数据清空。

四.数据库连接池的实现原理
	数据源DataSource对象什么时候创建数据库连接
		当我们需要创建SqlSession对象并需要执行SQL语句时，这时候MyBatis才会去调用dataSource对象来创建java.sql.Connection对象。也就是说，java.sql.Connection对象的创建一直延迟到执行SQL语句的时候。
	为什么要使用带连接池的数据源呢，最根本的原因还是因为每次创建连接开销比较大，频繁的创建和关闭数据库连接将会严重的影响性能。因此，常用的做法是维护一个数据库连接池，每次使用完之后并不是直接关闭数据库连接，再后面如果需要创建数据库连接的时候直接拿之前释放的数据库连接使用，避免频繁创建和关闭数据库连接造成的开销。
	在mybatis中，定义了一个数据库连接池状态的类PoolState，在这个类里，除维护了数据源实例，还维护着数据库连接。数据库连接被分成了两种状态类型并存放在两个列表中：idleConnections和activeConnections。
		a.idleConnections:
		空闲(idle)状态PooledConnection对象被放置到此集合中，表示当前闲置的没有被使用的PooledConnection集合，调用PooledDataSource的getConnection()方法时，会优先从此集合中取PooledConnection对象。当用完一个java.sql.Connection对象时，MyBatis会将其包裹成PooledConnection对象放到此集合中。
		
		b.activeConnections:	
		活动(active)状态的PooledConnection对象被放置到名为activeConnections的ArrayList中，表示当前正在被使用的PooledConnection集合，调用PooledDataSource的getConnection()方法时，会优先从idleConnections集合中取PooledConnection对象,如果没有，则看此集合是否已满，如果未满，PooledDataSource会创建出一个PooledConnection，添加到此集合中，并返回。
	
		我们看下上面的方法都做了什么：
	　　1.  先看是否有空闲(idle)状态下的PooledConnection对象，如果有，就直接返回一个可用的PooledConnection对象；否则进行第2步。
	　　2.查看活动状态的PooledConnection池activeConnections是否已满；如果没有满，则创建一个新的PooledConnection对象，然后放到activeConnectio
		ns池中，然后返回此PooledConnection对象；否则进行第三步；	3.看最先进入activeConnections池中的PooledConnection对象是否已经过期：如果已经过期，从activeConnections池中移除此对象，然后创建一个新的PooledConnection对象，添加到activeConnections中，然后将此对象返回；否则进行第4步；
	　　4.线程等待，循环2步。
	当我们拿到数据库连接PooledConnection后，我们在使用完之后一般来说就要关闭这个数据库连接，但是，对于池化来说，我们关闭了一个数据库连接并不是真正意义上想关闭这个连接，而是想把它放回到数据库连接池中。

	