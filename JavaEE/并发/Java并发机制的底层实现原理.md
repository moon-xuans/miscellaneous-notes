# 1.Java并发机制的底层实现原理

首先，我们都知道，Java代码在编译后会变成Java字节码，字节码被类加载器加载到JVM里，JVM执行字节码，最终需要转换成汇编指令在CPU上执行。那么我们想一下，我们Java代码中的并发操作是在哪里处理的呢？

答案是在JVM的实现和CPU的指令。

那我们带着好奇来探索下Java并发机制的底层实现原理。

## 1.1.volatile的应用

在我们平时的并发编程中使用的最多应该就是synchronized和volatile。volatile是轻量级的synchronized，它可以保证多处理器开发中共享变量的”可见性“。

> 可见性：当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。

如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。

我们先了解下volatile的定义。

### 1.1.1.volatile的定义与实现原理

Java语言规范第3版中对volatile的定义如下：

>  Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。

如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。

volatile是如何来保证可见性的呢？我们使用volatile修饰一个变量，然后查看其汇编指令发现，对volatile进行写操作时。CPU会做什么事情。

例如：

```java
instance = new Singleton(); // instance是volatile变量
```

![image-20220101095803382](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220101095803382.png)

有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码。通过查看IA-32架构软件开发者手册可知，Lock前缀的指令在多核处理器下会引发了两件事情。

- 将当前处理器缓存行的数据写回到系统内存。
- 这个写回内存的操作会使其他CPU里缓存了该内存地址的数据无效。

为了提高处理速度，处理器不直接和内存进行通信，而是将系统内存的数据读到内部缓存(L1,L2或其他)后再进行操作，但操作完不知道何时会写到内存。如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧制的，再执行计算操作就会有问题。

所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。

下面来看看volatile的两条实现原则。

**1)Lock前缀指令会引起处理器缓存回写到内存。**如果访问的内存区域已经缓存处理器内部，则不会声言LOCK#信号。相反，它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据。

**2)一个处理器的缓存回写到内存会导致其他处理器的缓存无效**。如果通过嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理器将使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充。

(注：具体实现细节可以看《Java并发编程的艺术》)

### 1.1.2.volatile的使用优化

著名的Java并发编程大师Doug lea在JDK7的并发包里新增一个队列集合类LinkedTransferQueue，它在使用volatile变量时，用一种追加字节的方式来优化队列出队和入队的性能。LinkedTransferQueue的代码如下。

![image-20220101101700646](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220101101700646.png)

我们先想想为什么**追加字节能修改性能？**，我们先看看LinkedTransferQueue这个类，它使用一个内部类类型来定义队列的头结点和尾结点，而这个内部类PaddedAtomicReference相对于父类AtomicReference只做了一件事情，就是将共享变量追加到64字节。我们可以计算下，一个对象的引用占4个字节，刚好追加了15变量，再加上父类的value变量。

**为什么追加64字节能够提高并发编程的效率呢？**因为对于一些处理器的L1、L2或L3缓存的高速缓存行是64个字节，不支持部分填充缓存行，这意味着，如果队列的头结点和尾结点都不足64字节的话，处理器会将它们都读到同一个高速缓存行中，在多处理器下每个处理器都会缓存同样的头、尾结点，当一个处理器试图修改头结点时，会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致其他处理器不能访问自己高速缓存中的尾结点，而队列的入队和出队操作则需要不停修改头节点和尾结点，所以在多处理器的情况下将会严重影响到队列的入队和出队效率。Doug lea使用追加64字节的方式来填满高速缓存区的缓存行，避免头结点和尾结点加载到同一个缓存行，使头、尾结点在修改时不会互相锁定。

**那么是不是在使用volatile变量时多应该追加到64字节呢？**答案，不是的。有两种情况不应该使用这种方式。

- **缓存行非64字节宽的处理器**。并不是所有的处理器的高速缓存行是64个字节，还有其他的处理器是32个字节宽。
- **共享变量不会被频繁的写。**因为使用追加字节的方式需要处理器读取更多的字节到高速缓冲区，这本身就会带来一定的性能消耗，如果共享变量不被频繁写的话，锁的几率也非常小，就没必要通过追加字节的方式来避免相互锁定。

这种追加字节的方式在Java7下可能不生效，因为Java7变得更加智慧，它会淘汰或重新排列无用字段，需要使用其他追加字节的方式。

## 1.2.synchronized的实现原理与应用

synchronized一般会被人称作重量级锁。但是在Java6对其进行了各种优化之后，就没有那么”重“了。它为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁。

先看下利用synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现为以下3种形式。(有兴趣的看关于synchronized的八锁问题)

- 对于普通同步方法，锁是当前实例对象。
- 对于静态同步方法，锁是当前类的Class对象。
- 对于同步方法块，锁是Synchronized括号里配置的对象。

当一个线程视图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。那么锁到底存在哪里呢？锁里面会存储什么信息呢？

在JVM规范中可以看到Synchronized在JVM里的实现原理，JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用monitorenter和monitorexit指令实现的，而方法同步是使用另外一种方式实现的。但是，方法的同步同样可以使用这两个指令来实现。

monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。

### 1.2.1.Java对象头

synchronized用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽(Word)存储对象头，如果对象是非数组类型，则用2个字宽存储对象头。在32位虚拟机中，1字宽等于4字节，即32bit。

Java对象头的内容如下图所示

![image-20220101105342229](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220101105342229.png)

Java对象头里的Mark Word里默认存储对象的HashCode、分代年龄和锁标记位。

Mark Word的默认存储结构如图所示

![image-20220101105539480](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220101105539480.png)

在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数据。

![image-20220101105856969](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220101105856969.png)

在64位虚拟机下，Mark Word是64bit大小的，其存储结构如图所示。

![image-20220101110017465](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220101110017465.png)

### 1.2.2.锁的升级与对比

Java6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在Java6中，锁一共有4种状态，级别从低到高依次是:无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。

#### 1.2.2.1.偏向锁

HotSpot的作者研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需要简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的表示是否设置成1(表示当前是偏向锁):如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。

(1)偏向锁的撤销

偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点(JVM中的)。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否或者，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。

撤销偏向锁的过程如下图所示。

![image-20220101112030753](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220101112030753.png)

(2)关闭偏向锁

偏向锁在Java6和Java7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟:-XX:BiasedLockingStartupDelay=0。如果确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁:-XX:-UseBiasedLocking=false,那么程序默认会进入轻量级锁状态。

#### 1.2.2.2.轻量级锁

(1)轻量级锁加锁

线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。

(2)轻量级锁解锁

轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。

下面是锁膨胀示例

![image-20220101113234409](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220101113234409.png)

因为自旋会消耗CPU，为了避免无用的自旋(比如获得锁的线程被阻塞住了)，一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁。

#### 1.2.2.3.锁的优缺点对比

![image-20220101113813295](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220101113813295.png)

## 1.3.原子操作的实现原理

原子本意是“不能被进一步分割的最小粒子”，而原子操作意味“不可被中断的一个或一系列操作”。在多处理器上实现原子操作就变得有点复杂，看看处理器和Java如何做到实现原子操作的。

### 1.3.1.处理器实现原子操作

处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。

(1)使用总线锁保证原子性

**第一个机制是通过总线锁保证原子性**。所谓总线锁就是使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。

(2)使用缓存锁保证原子性

**第二个机制是通过缓存锁定保证原子性**。在同一时刻，我们只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。

所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK#信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。

**有两种情况下处理器不会使用缓存锁定**。

第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，则处理器会调用总线缓存。

第二种情况是：有些处理器不支持缓存锁定。就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。

针对以上两种机制，intel处理器提供其他的lock前缀的指令来实现，被那些指令操作的内存区域就会加锁，导致其他处理器不能同时访问它。

### 1.3.2.Java如何实现原子操作

在Java中可以通过锁和循环CAS的方式来实现原子操作。

#### 1.3.2.1.使用循环CAS实现原子操作

JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止。

下面有一个基于CAS线程安全的计数器方法safeCount和一个非线程安全的计数器count。

```java
public class Counter {
    private AtomicInteger atomicI = new AtomicInteger(0);
    private int i = 0;

    public static void main(String[] args) {
        final Counter cas = new Counter();
        List<Thread> ts = new ArrayList<Thread>(600);
        long start = System.currentTimeMillis();
        for (int i = 0; i < 100; i++) {
            Thread t = new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 10000; j++) {
                        cas.count();
                        cas.safeCount();
                    }
                }
            });
            ts.add(t);
        }
        for (Thread t : ts) {
            t.start();
        }

        // 等待所有线程执行完成
        for (Thread t : ts) {
            try {
                t.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(cas.i);
            System.out.println(cas.atomicI.get());
            System.out.println(System.currentTimeMillis() - start);;
        }
    }

    // 使用CAS实现线程安全计数器
    private void safeCount() {
        for (; ;) {
            int i = atomicI.get();
            boolean suc = atomicI.compareAndSet(i, ++i);
            if (suc) {
                break;
            }
        }
    }

    // 非线程安全计数器
    private void count() {
        i++;
    }
}

```



![image-20220101145436866](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20220101145436866.png)

从实验结果，我们可以看出，i++并不是原子操作，并且AtomicInteger可以完成原子操作

从Java5开始，JDK的并发包里提供了一些类来支持原子操作，如AtomicBoolean、AtomicInteger和AtomicLong，它们可以以原子的方式完成自增1和自减1。

#### 1.3.2.2.CAS实现原子操作的三大问题

CAS虽然很高效地解决了原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大，以及只能保证一个共享变量的原子操作。

**1)ABA问题**。因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用功能CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A -> B - > A 就会变成1A->2B->3A。从Java5开始，JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

**2)循环时间开销大**。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。

**3）只能保证一个共享变量的原子操作**。当对一个共享变量执行操作时，我们可以会使用循环CAS的方式来保证原子性，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。从Java5开始，JDK提供AtomicReference来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。

#### 1.3.2.3.使用锁机制实现原子操作

锁机制保证了只有获得锁的线程才能够操作特定的内存区域。JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。



(注：内容参考自《Java并发编程的艺术》)

