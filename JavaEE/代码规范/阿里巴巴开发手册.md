# 阿里巴巴开发手册

## 一、编程规约

### 1.命名风格

#### 1.1.各层命名规约

1.获取单个对象用`get`做前缀

2.获取多个对象用`list`做前缀，复数形式结尾

3.获取统计值的方法用`count`做前缀

4.插入的方法用`save/insert`做前缀

5.删除的方法用`remove/delete`做前缀

6.修改的方法用`update`做前缀

### 2.常量定义

### 2.1.不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护

大而全的常量类，杂乱无章，使用查找功能才能定位到修改的常量，不利于理解和维护。

### 3.代码格式

#### 3.1.单行字符数限制不超过120个，超出需要换行，换行时遵循如下原则

1.第二行相对第一行缩进4个空格，从第三行开始，不再继续缩进；

2.运算符与下文一起换行；

3.方法调用的点符号与下文一起换行；

4.在多个参数超长，在逗号后换行；

5.在括号前，不要换行；

![换行示例](https://raw.githubusercontent.com/moon-xuans/mediaImage/master/2024/20240416205900.png)

### 4.OOP规约

#### 4.1.外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated注解，并清晰地说明采用的新接口或者新服务式什么

#### 4.2.Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals

推荐使用java.util.Objects#equals

#### 4.3.关于基本数据类型与包装数据类型的使用标准

1.所有的POJO类属性必须使用包装数据类型

2.RPC方法的返回值和参数必须使用包装数据类型

3.所有的局部变量使用基本数据类型

#### 4.4.定义DO/DTO/VO等POJO类时，不要设定任何属性默认值

#### 4.5.当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读，这条规则优先于下一条规则

#### 4.6.类内方法定义的顺序依次是：共有方法或保护方法 > 私有方法 > getter/setter方法

### 5.集合处理

#### 5.1.使用entrySet遍历Map类集合KV，而不是keySet方法进行遍历

keySet其实是遍历了2次，一次是转为Iterator对象，另一次是从hashMap中取出key所对应的value。而entrySet只是遍历了一次就把key和value放到了entry中，效率更高。如果是JDK8，使用Map.foreach方法。

### 6.并发处理

#### 6.1.线程资源必须通过线程池提供，不允许在应用中自行显示创建线程

使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题

#### 6.2.线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方法

#### 6.3.并发修改统一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用version作为更新依据。

如果每次方法冲突概率小于20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于3次。

#### 6.4.volatile解决多线程内存不可见的问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题

如果是count++操作，使用AtomicInteger count = new AtomicInteger();count.addAndGet(1);如果是JDK8，推荐使用LongAdder对象，比AtomicLong性能更好(减少乐观锁的重试次数)

### 7.控制语句

#### 7.1.在if/else/for/while/do语句中必须使用大括号。即使只有一行代码，避免采用单行的编码方法:if (condition) statements

#### 7.2.在高并发场景中，避免使用“等于”判断作为中断或者退出的条件

如果并发控制没有处理好，容易产生等值判断被“击穿”的情况，使用大于或小于的区间判断条件来代替。

#### 7.3.表达异常的分支时，少用if-else方法，这种方式可以改写成

```java
if (condition) {
    ...
    return obj;
}
```

超过3层的if-else的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句实例如下:

![卫语句示例](https://raw.githubusercontent.com/moon-xuans/mediaImage/master/2024/20240417200728.png)

#### 7.4.除常用方法(如getXxx/isXxx)等外，不要在条件判断中执行其他复杂的语句，将复杂逻辑判断的结果赋给一个有意义的布尔变量名，以提高可读性

![布尔结果示例](https://raw.githubusercontent.com/moon-xuans/mediaImage/master/2024/20240417201022.png)

#### 7.5.循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的try-catch操作(这个try-catch是否可以移至循环体外)

#### 7.6.避免采用取反逻辑运算符

取反逻辑不利于快速理解，并且取反写法必然存在对应的正向逻辑写法

### 8.注释规约

#### 8.1.所有类都必须添加创建者和创建日期

#### 8.2.所有的枚举类型字段必须要有注释，说明每个数据项的用途

#### 8.3.对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能理解当时的思路；注释也是给继任者看的，使其能够迅速接替自己的工作

#### 8.4.好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担

### 9.其他

#### 9.1.及时清理不再使用的代码段或配置信息

对于垃圾代码或过时配置，坚决清理干净，避免程序过度臃肿，代码冗余。

对于暂时被注释掉，后续可能恢复使用的代码片断，在注释代码上方，统一规定使用三个斜杠(///)来说明注释掉代码的理由。

## 二、异常日志

### 1.异常处理

#### 1.1.有try块放到了事务代码中，catch异常后，如果需要回滚事务，一定要注意手动回滚事务

#### 1.2.方法的返回值可以为null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回null值

#### 1.3.防止NPE，是程序员的基本修养，注意NPE产生的场景

1.返回类型为基本数据类型，return包装数据类型的对象时，自动拆箱有可能产生NPE。

```java
public int f() {
    return Integer对象
} 
如果为null，自动拆箱抛NPE
```

2.数据库的查询结果可能为null。

3.集合里的元素即使isNotEmpty,取出的元素有可能为null。

4.远程调用返回对象时，一律要求进行空指针判断，防止NPE。

5.对于Session中获取的数据，建议NPE检查，避免空指针。

6.级联调用obj.getA().getB().getC();一连串调用，易产生NPE。(使用JDK8的Optional类来防止NPE问题)

#### 1.4.避免出现重复的代码(Don't Repeat Yourself)，即DRY原则

随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是组件化。

## 二、日志规约

### 1.异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过throws往上抛出

### 2.可以使用warn日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。如非必要，请不要在此场景打出error级别，避免频繁报警

注意日志输出的级别，error级别只记录系统逻辑错误、异常或重要的错误信息。

### 3.尽量用英文来描述日志错误信息，如果日志中的错误信息用英文描述不清楚的话使用中文描述即可，否则容易产生歧义。国际化团队或海外部署的服务器由于字符集问题，使用全英文来注释和描述日志错误信息

## 三、单元测试

### 1.好的单元测试必须遵守AIR原则

单元测试在线上运行时，感觉像空气(AIR)一样并不存在，但在测试质量的保障上，却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复性的特点。

- A： Automic(自动化)
- I: Independent(独立性)
- R: Repeatable(可重复性)

### 2.单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，执行过程必须是完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。单元测试中不准使用System.out来进行人肉验证，必须使用assert来验证

### 3.保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后顺序

### 4.单元测试是可以重复执行的，不能受到外界环境的影响

单元测试通常会放到持续集成中，每次有代码check in时单元测试都会被执行。如果单测对外部环境(网络、服务、中间件等)有依赖，容易导致持续集成机制的不可用

### 5.对于单元测试，要保证测试粒度足够小，有助于精准定位问题。单测粒度至多是类级别，一般是方法级别

只有测试粒度小才能在出错时尽快定位到出错位置。单测不负责检查跨类或者跨系统的交互逻辑，那是集成测试的领域。

### 6.和数据库相关的单元测试，可以设定为自动回滚机制，不给数据库造成脏数据。或者对单元测试产生的数据有明确的前后缀标识

在RDC内部单元测试中，使用RDC_UNIT_TEST_的前缀标识数据。

### 7.对于不可测的代码建议做必要的重构，使代码变得可测，避免为了达到测试要求而书写不规范测试代码

## 4.MySQL数据库

### 4.1.建表规约

#### 1.表达是否概念的字段，必须使用is_xxx的方式命名，数据类型是unsigned tinyint(1表示是，0表示否)

任何字段如果是非负数，必须是unsigned。

POJO类中的任何布尔类型的变量，都不要加is前缀，所以，需要在< resultMap >设置从is_xxx到Xxx的映射关系。数据库表示是与否的值，使用tinyint类型，坚持is_xxx的命名方式是为了明确其取值含义与取值范围。

#### 2.表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重开率

MySQL在Windows下不区分大消息，但在Linux下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。

#### 3.表名不使用复数名词

表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于DO类名也是单数形式，符合表达习惯。

#### 4.禁用保留字，如desc、range、match、delayed等，请参考MySQL官方保留字

#### 5.主键索引名为pk_字段名；唯一索引名为uk_字段名；普通索引名则为idx_字段名

#### 6.小数类型为decimal，禁止使用float和double

float和double在存储的时候，存在精度损失的问题，很可能在值的比较时，得不到正确的结果。如果存储的数据范围超过decimal的范围，建议将数据拆成整数和小数分开存储。

#### 7.如果存储的字符串长度几乎相等，使用char定长字符串类型

#### 8.varchar是可变长字符串，不预先分配存储空间，长度不要超过5000，如果存储长度大于此值，定义字段类型为text，独立出现一张表，用主键来对应，避免影响其他字段索引效率

#### 9.表必备三字段：id，gmt_create，gmt_modified

其中id必为主键，类型为bigint unsigned、单表时自增、步长为1。gmt_create，gmt_modified的类型均为datetime类型，前者现在时表示主动创建，后者过去分词表示被动更新。

#### 10.表的命名最后是加上”业务名称_表的作用“

> 例: alipay_task/force_project/trade_config

#### 11.库名与应用名称尽量一致

#### 12.如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释

#### 13.字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循

1）不是频繁修改的字段

2）不是varchar超长字段，更不能是text字段。

> 例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。

#### 14.合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度

### 二、索引规约

#### 1.业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引

不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查询速度是明显的；另外，即使在应用层做了非常完善的校验机制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生

#### 2.超过三个表禁止join。需要join的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引

即使双表join也要注意表索引、SQL性能

#### 3.在varchar字段上建议索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可

#### 4.利用覆盖索引来进行查询操作，避免回表

如果一本书需要知道第11章是什么标题，会翻开第11章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。

能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效果，用explain的结果，extra列会出现：using index。

#### 5.创建索引时避免有如下极端误解

1.宁滥勿缺。认为一个查询就需要建一个索引。

2.宁缺毋滥。认为索引会消耗空间、严重拖慢更新和新增速度。

3.抵制唯一索引。认为业务的唯一性一律需要在应用层通过”先查后插“方式解决。

### 三、SQL语句

#### 1.不要使用count(列名)或count(常量)来替代count(*)，count(\*)是SQL92定义的标准统计行数的语法，跟数据库无关，跟NULL和非NULL无关

count(*)会统计之为NULL的行，而count(列名)不会统计此列为NULL值的行。

#### 2.count(distinct col)计算该列除NULL之外的不重复行数，注意count(distinct col1, distinct col2)如果其中一列全为NULL，那么即使另一列有不同的值，也返回为0

#### 3.当某一列的值全是NULL,count(col)的返回结果为0，但sum(col)的返回结果为NULL，因此使用sum()时需要注意NPE问题

可以使用如下方式来避免sum的NPE问题:SELECT IF(ISNULL(SIM(g)), 0, sum(g)) form table。

#### 4.在代码中写分页查询逻辑时，若count为0应直接返回，避免执行后面的分页语句

#### 5.不得使用外键与级联，一切外键概念必须在应用层解决

#### 6.数据订正(特别是删除、修改记录操作)时，要先select，避免出现误操作，确认无误才能执行更新语句。