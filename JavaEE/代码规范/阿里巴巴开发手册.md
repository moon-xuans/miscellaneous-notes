# 阿里巴巴开发手册

## 一、编程规约

### 1.命名风格

#### 1.1.各层命名规约

1.获取单个对象用`get`做前缀

2.获取多个对象用`list`做前缀，复数形式结尾

3.获取统计值的方法用`count`做前缀

4.插入的方法用`save/insert`做前缀

5.删除的方法用`remove/delete`做前缀

6.修改的方法用`update`做前缀

### 2.常量定义

### 2.1.不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护

大而全的常量类，杂乱无章，使用查找功能才能定位到修改的常量，不利于理解和维护。

### 3.代码格式

#### 3.1.单行字符数限制不超过120个，超出需要换行，换行时遵循如下原则

1.第二行相对第一行缩进4个空格，从第三行开始，不再继续缩进；

2.运算符与下文一起换行；

3.方法调用的点符号与下文一起换行；

4.在多个参数超长，在逗号后换行；

5.在括号前，不要换行；

![换行示例](https://raw.githubusercontent.com/moon-xuans/mediaImage/master/2024/20240416205900.png)

### 4.OOP规约

#### 4.1.外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated注解，并清晰地说明采用的新接口或者新服务式什么

#### 4.2.Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals

推荐使用java.util.Objects#equals

#### 4.3.关于基本数据类型与包装数据类型的使用标准

1.所有的POJO类属性必须使用包装数据类型

2.RPC方法的返回值和参数必须使用包装数据类型

3.所有的局部变量使用基本数据类型

#### 4.4.定义DO/DTO/VO等POJO类时，不要设定任何属性默认值

#### 4.5.当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读，这条规则优先于下一条规则

#### 4.6.类内方法定义的顺序依次是：共有方法或保护方法 > 私有方法 > getter/setter方法

### 5.集合处理

#### 5.1.使用entrySet遍历Map类集合KV，而不是keySet方法进行遍历

keySet其实是遍历了2次，一次是转为Iterator对象，另一次是从hashMap中取出key所对应的value。而entrySet只是遍历了一次就把key和value放到了entry中，效率更高。如果是JDK8，使用Map.foreach方法。

### 6.并发处理

#### 6.1.线程资源必须通过线程池提供，不允许在应用中自行显示创建线程

使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题

#### 6.2.线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方法

#### 6.3.并发修改统一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用version作为更新依据。

如果每次方法冲突概率小于20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于3次。

#### 6.4.volatile解决多线程内存不可见的问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题

如果是count++操作，使用AtomicInteger count = new AtomicInteger();count.addAndGet(1);如果是JDK8，推荐使用LongAdder对象，比AtomicLong性能更好(减少乐观锁的重试次数)

### 7.控制语句

#### 7.1.在if/else/for/while/do语句中必须使用大括号。即使只有一行代码，避免采用单行的编码方法:if (condition) statements

#### 7.2.在高并发场景中，避免使用“等于”判断作为中断或者退出的条件

如果并发控制没有处理好，容易产生等值判断被“击穿”的情况，使用大于或小于的区间判断条件来代替。

#### 7.3.表达异常的分支时，少用if-else方法，这种方式可以改写成

```java
if (condition) {
    ...
    return obj;
}
```

超过3层的if-else的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句实例如下:

![卫语句示例](https://raw.githubusercontent.com/moon-xuans/mediaImage/master/2024/20240417200728.png)

#### 7.4.除常用方法(如getXxx/isXxx)等外，不要在条件判断中执行其他复杂的语句，将复杂逻辑判断的结果赋给一个有意义的布尔变量名，以提高可读性

![布尔结果示例](https://raw.githubusercontent.com/moon-xuans/mediaImage/master/2024/20240417201022.png)

#### 7.5.循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的try-catch操作(这个try-catch是否可以移至循环体外)

#### 7.6.避免采用取反逻辑运算符

取反逻辑不利于快速理解，并且取反写法必然存在对应的正向逻辑写法

### 8.注释规约

#### 8.1.所有类都必须添加创建者和创建日期

#### 8.2.所有的枚举类型字段必须要有注释，说明每个数据项的用途

#### 8.3.对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能理解当时的思路；注释也是给继任者看的，使其能够迅速接替自己的工作

#### 8.4.好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担

### 9.其他

#### 9.1.及时清理不再使用的代码段或配置信息

对于垃圾代码或过时配置，坚决清理干净，避免程序过度臃肿，代码冗余。

对于暂时被注释掉，后续可能恢复使用的代码片断，在注释代码上方，统一规定使用三个斜杠(///)来说明注释掉代码的理由。

## 二、异常日志

### 1.异常处理

#### 1.1.有try块放到了事务代码中，catch异常后，如果需要回滚事务，一定要注意手动回滚事务

#### 1.2.方法的返回值可以为null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回null值

#### 1.3.防止NPE，是程序员的基本修养，注意NPE产生的场景

1.返回类型为基本数据类型，return包装数据类型的对象时，自动拆箱有可能产生NPE。

```java
public int f() {
    return Integer对象
} 
如果为null，自动拆箱抛NPE
```

2.数据库的查询结果可能为null。

3.集合里的元素即使isNotEmpty,取出的元素有可能为null。

4.远程调用返回对象时，一律要求进行空指针判断，防止NPE。

5.对于Session中获取的数据，建议NPE检查，避免空指针。

6.级联调用obj.getA().getB().getC();一连串调用，易产生NPE。(使用JDK8的Optional类来防止NPE问题)

#### 1.4.避免出现重复的代码(Don't Repeat Yourself)，即DRY原则

随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是组件化。

