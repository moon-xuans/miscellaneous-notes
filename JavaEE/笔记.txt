1.java基础
	1.接口和抽象类的区别:
		1.接口里只能包含抽象方法，静态方法和默认方法，不能为普通方法提供方法实现，抽象类完全可以包含普通方法；
		2.接口里只能定义静态常量，不能定义普通成员变量，抽象类里则既可以定义普通成员变量，也可以定义静态常量；
		3.接口不能包含构造器，抽象类可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。
		4.接口里不能包含初始化块，但抽象类里完全可以包含初始化块。
		5.一个类最多只能有一个直接父类，包括抽象类，但一个类可以直接实现多个接口，通过实现多个接口可以弥补Java单继承不足。
	2.八大基本类型的缓存
		java的包装类中：Byte，Short，Integer，Long，Character使用static代码块进行初始化缓存，其中Integer的最大值可以通过java.lang.Integer.IntegerCache.high设置；Boolean使用static final实例化的对象；Float和Double直接new的对象没有使用缓存
		
		由String的不可变性引申到其他基本数据类型： Byte,Short,Integer,Long,Double,Float,Character,Boolean 八种基本数据的包装类，仔细查看发现也是final修饰的，再仔细查看一下enum枚举类型，发现用javac编译后再用javap反编译也是被编译为final修饰的类，并且其枚举值全部定义为static final 修饰的成员变量。
		
		Java设计者在设计Java基本数据类型时，把基本数据类型全部设计为不可变的，这样既方便了开发人员，又保证了数据的安全性。
	3.java的异常
		Java标准裤内建了一些通用的异常，这些类以Throwable为顶层父类。

		Throwable又派生出Error类和Exception类。
		错误：Error类以及他的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，Error很少出现。因此，程序员应该关注Exception为父类的分支下的各种异常类。Error的例子，Out Of Memory Error，Stack Overflow Error;

		异常：Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。(大致可以分为RunTimeException和IOException等等)
		
		总体上又可以分为：
			非检查异常:javac在编译时，不会提示和发现这样的异常，不要求在程序处理这些异常。所以如果愿意，我们可以编写代码处理（使用try...catch...finally）这样的异常，也可以不处理。对于这些异常，我们应该修正代码，而不是去通过异常处理器处理 。这样的异常发生的原因多半是代码写的有问题。
			检查异常:javac强制要求程序员为这样的异常做预备处理工作（使用try...catch...finally或者throws）。在方法中要么用try-catch语句捕获它并处理，要么用throws子句声明抛出它，否则编译不会通过。这样的异常一般是由程序的运行环境导致的。因为程序可能被运行在各种未知的环境下，而程序员无法干预用户如何使用他编写的程序，于是程序员就应该为这样的异常时刻准备着。
	4.java1.8的新特性
		1.四大函数式接口，可以使用lambda表达式
			1.Consumer<T>消费型接口: 对类型为T的对象应用操作，包含方法: void accept(T t);
			2.Supplier<T>供给型接口:
			返回类型为T的对象，包含方法: T get();
			3.Function<T, R>函数型接口:
			对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法: R apply (T t);
			4.Predicate<T>断定性接口:
			确定类型为T的对象是否满足某约束，并返回boolean值。包含方法boolean test(T t);
		2.Stream流式计算
			"集合讲的是数据，流讲的是计算！"
			
			特点:
				1.Stream自己不会存储元素。
				2.Stream不会改变数据源，相反，他们会返回一个特有结果的Stream。
				3.Stream操作是延迟执行的。这意味着他们会等到需要结果的时候才会执行。
			
			Stream数据流基本操作
				数据源	->		中间操作 ->		终端操作
				Collection集合	filter过滤		收集为Collection
				IO流			distinct去重	收集为Array
				...				map映射			收集为String
								sorted排序		count计算元素数量
								limit截取		max计算最大值
								...				min计算最小值
		3.使用lambda表达式为什么会变慢？
			a.Lambda表达式 在应用程序中首次使用时，需要额外加载ASM框架，因此需要更多的编译，加载的时间
			b.Lambda表达式的底层实现并非匿名内部类的语法糖，而是其优化版
	5.String、String StringBuffer 和 StringBuilder 的区别是什么?
		String是只读字符串，它并不是基本数据类型，而是一个对象。从底层源码来看是一个final类型的
		字符数组，所引用的字符串不能被改变，一经定义，无法再增删改。每次对String的操作都会生成
		新的String对象。
		
		每次+操作 ： 隐式在堆上new了一个跟原字符串相同的StringBuilder对象，再调用append方法拼接+后面的字符。

		StringBuffer和StringBuilder他们两都继承了AbstractStringBuilder抽象类，从AbstractStringBuilder抽象类中我们可以看到
		他们的底层都是可变的字符数组，所以在进行频繁的字符串操作时，建议使用StringBuffer和
		StringBuilder来进行操作。 另外StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所
		以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的
		
	6.基本类型和包装类型： 
		1.int是基本数据类型，Integer是int的包装类，是引用类型。int默认值是0，而Integer默认值是null，所以Integer能区分出0和null的情况。
		
		一旦java看到null，就知道这个引用还没有指向某个对象，在任何引用使用前，必须为其指定一个对象，否则会报错。
		
		2.基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间，必须通过实例化开辟数据空间之后才可以赋值。
		
		数组对象也是一个引用对象，将一个数组赋值给另一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看的见。
		
		(虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持。在Java虚拟机中没有
		任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java
		虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，每个元素
		boolean元素占8位。这样我们可以得出boolean类型占了单独使用是4个字节，在数组中又是1个字
		节。使用int的原因是，对于当下32位的处理器（CPU）来说，一次处理数据是32位（这里不是指的
		是32/64位系统，而是指CPU硬件层面），具有高效存取的特点。)
	7.Java自动装箱与拆箱
		装箱就是自动将基本数据类型转换为包装器类型（int-->Integer）；调用方法：Integer的valueOf(int) 方法
		
		拆箱就是自动将包装器类型转换为基本数据类型（Integer-->int）。调用方法：Integer的intValue方法
		
		通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象
	8.重写与重载的区别
		重写： 
			1.发生在父类与子类之间 
			2.方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同 
			3.访问修饰符的限制一定要大于被重写方法的访问修饰符（public>protected>default>private) 
			4.重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常
		重载:
			 1.重载Overload是一个类中多态性的一种表现 
			 2.重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序) 
			 3.重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准
	9.equals和==的区别
		== ：
			== 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是
			否是指相同一个对象。比较的是真正意义上的指针操作。
			1、比较的是操作符两端的操作数是否是同一个对象。 2、两边的操作数必须是同一类型的（可以是
			父子类之间）才能编译通过。 3、比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为
			true，如： int a=10 与 long b=10L 与 double c=10.0都是相同的（为true），因为他们都指向地
			址为10的堆。
		equals：
			equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所
			以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object
			中的equals方法返回的却是==的判断。
	10.hashCode的作用
		hashCode方法可以这样理解：它返回的就是根据对象的内存地址换算出的一个值。这样一来，当
		集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理
		位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如
		果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相
		同就散列其它的地址。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。
	11.使用泛型的好处？
		以集合来举例，使用泛型的好处是我们不必因为添加元素类型的不同而定义不同类型的集合，如整
		型集合类，浮点型集合类，字符串集合类，我们可以定义一个集合来存放整型、浮点型，字符串型
		数据，而这并不是最重要的，因为我们只要把底层存储设置了Object即可，添加的数据全部都可向
		上转型为Object。 更重要的是我们可以通过规则按照自己的想法控制存储的数据类型。
	12.Java创建对象有几种方式？
		java中提供了以下四种创建对象的方式:
			1.new创建新对象
			2.通过反射机制
			3.采用clone机制
			4.通过序列化机制
	13.final有哪些用法?
		final也是很多面试喜欢问的地方,但我觉得这个问题很无聊,通常能回答下以下5点就不错了: 
			1.被final修饰的类不可以被继承
			2.被final修饰的方法不可以被重写
			3.被final修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变. 
			4.被final修饰的方法,JVM会尝试将其内联,以提高运行效率
			5.被final修饰的常量,在编译阶段会存入常量池中.
	14.a=a+b与a+=b有什么区别吗?
		+= 操作符会进行隐式自动类型转换,此处a+=b隐式的将加操作的结果类型强制转换为持有结果的类
		型,而a=a+b则不会自动进行类型转换.
	15.Object 有哪些常用方法？大致说一下每个方法的含义
		1.clone 方法
			保护方法，实现对象的浅复制，只有实现了 Cloneable 接口才可以调用该方法，否则抛出
			CloneNotSupportedException 异常，深拷贝也需要实现 Cloneable，同时其成员变量为引用类型
			的也需要实现 Cloneable，然后重写 clone 方法。
		2.finalize 方法
			该方法和垃圾收集器有关系，判断一个对象是否可以被回收的最后一步就是判断是否重写了此方法。
		3.equals 方法
			该方法使用频率非常高。一般 equals 和 == 是不一样的，但是在 Object 中两者是一样的。子类一般都要重写这个方法。
		4.hashCode 方法
			该方法用于哈希查找，重写了 equals 方法一般都要重写 hashCode 方法，这个方法在一些具有哈
			希功能的 Collection 中用到。
			一般必须满足 obj1.equals(obj2)==true 。可以推出 obj1.hashCode()==obj2.hashCode() ，但是
			hashCode 相等不一定就满足 equals。不过为了提高效率，应该尽量使上面两个条件接近等价。
				JDK 1.6、1.7 默认是返回随机数；
				JDK 1.8 默认是通过和当前线程有关的一个随机数 + 三个确定值，运用 Marsaglia’s xorshift
			scheme 随机数算法得到的一个随机数。
		5.wait 方法
			配合 synchronized 使用，wait 方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥
			有者，也就是具有该对象的锁。wait() 方法一直等待，直到获得锁或者被中断。wait(long timeout)
			设定一个超时间隔，如果在规定时间内没有获得锁就返回。
			调用该方法后当前线程进入睡眠状态，直到以下事件发生。
				1. 其他线程调用了该对象的 notify 方法；
				2. 其他线程调用了该对象的 notifyAll 方法；
				3. 其他线程调用了 interrupt 中断该线程；
				4. 时间间隔到了。
			此时该线程就可以被调度了，如果是被中断的话就抛出一个 InterruptedException 异常。
		6.notify 方法
			配合 synchronized 使用，该方法唤醒在该对象上等待队列中的某个线程（同步队列中的线程是给
			抢占 CPU 的线程，等待队列中的线程指的是等待唤醒的线程）。
		7.notifyAll 方法
			配合 synchronized 使用，该方法唤醒在该对象上等待队列中的所有线程
	16.红黑树的特点
		1.节点颜色有红色和黑色
		2.根节点必为黑色
		3.所有叶子节点都是黑色
		4.任意节点到叶子节点经过的黑色节点数目相同
		5.不会有连续的红色节点
2.集合框架
	1.HashMap
		JDK1.8之前HashMap底层是数组和链表结合在一起使用也就是链表散列。	
		HashMap通过key的hashCode经过扰动函数处理过后得到hash值，然后通过(n – 1) & hash判断当前元素存放的位置(这里的n指的是数组的长度)，如果当前位置存放元素的话，就判断该元素要与存入的元素的hash值以及key是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。
		相比于之前的版本，JDK1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值(默认为8)(将链表转换为红黑树前会判断，如果当前数组的长度小于64，那么会选择先进行数组扩容，而不是转换为红黑树)时，将链表转化为红黑树，以减少搜索时间。
		
		JDK1.8的hash方法，相比于JDK1.7方法更加简化，但是原理不变。
		
		HashMap的长度为什么是2的幂次方?
		
			“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&)操作（也就是说 hash%length hash&(length-1)的前提是 length 是 2 的 n 次方；）。” 并且 采用二进制位操作 &，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。
			
		为什么链表长度达到8之后才开始转换为红黑树？
			因为通常情况下，链表长度很难达到8，但是特殊情况下链表长度为8，哈希表容量又很大，造成链表性能很差的时候，只能采用红黑树提高性能，这是一种应对策略。
		
		需要注意的是:在jdk1.7的时候，使用头插法进行移动元素，如果在新表的数组索引位置相同，则链表元素会倒置，但是jdk1.8不会倒置。它是使用尾插法，避免了在1.7时扩容出现死循环的情况。 

		由于我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，经过rehash之后，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。
	2.ConcurrentHashMap
		1.出现的原因
			我们最常用的集合框架一定包括HashMap，但是都知道它不是线程安全的。在并发插入元素的时候，有可能出现带环链表，让下一次读操作出现死循环。
			而想要次避免HashMap的线程安全问题有很多办法，比如改用HashTable或者Collections.synchronizedMap。但是，这两者有着共同的问题：性能。无论读操作还是写操作，它们都会给整个集合加锁，导致同一时间的其他操作为之阻塞。
		2.ConcurrentHashMap底层结构
			1.JDK1.7之前
				在了解ConcurrentHashMap之前，首先要了解一个概念Segment。Segment本身就相当于一个HashMap对象。
				Segment事实上是一个可重入锁，它继承了Reentrantlock.
				同HashMap一样，Segment包含一个HashEntry数组，数组中的每一个HashEntry既是一个键值对，也是一个链表的头结点。
				像这样的Segment对象，在ConcurrentHashMap集合中有多少个呢?有2的N次方个，共同保存在一个名为segments的数组当中。		
				可以说，ConcurrentHashMap是一个二级哈希表。在一个总的哈希表下面，有若干个自哈希表。
				使用这样锁分段技术，每一个Segment就好比一个自治区，读写操作高度自治，Segment之间互不影响。
				
				几种场景:
					1.不同Segment的写入是可以并发执行的。
					2.同一Segment的写和读是可以并发执行的。
					3.Segment的写入是需要上锁的，因此对同一Segment的并发写入会被阻塞。
					由此可见，ConcurrentHashMap当中每个Segment各自持有一把锁。在保证线程安全的同时降低了锁的粒度，让并发操作效率更高。
				
				Get方法
					1.为输入的Key做hash运算，得到hash值。
					2.通过hash值，定位到对应的segment对象。
					3.再次通过hash值，定位到segment当中的数组的具体位置。
					
				Put方法
					1.为输入的key做hash运算，得到hash值。
					2.通过hash值，定位到对应的segment对象。
					3.获取可重入锁。
					4.再次通过hash值，定位到segment当中数组的具体位置。
					5.插入或覆盖hashEntry对象。
					6.释放锁。
					可以看出ConcurrentHashMap在读写时都需要二次定位。首先定位到segment，之后定位到segment内的具体数组下标。

				在调用size方法的时候，如何解决一致性的问题？
					size方法的目的是统计ConcurrentHashMap的总元素数量，自然需要把各个segment内部的元素数量汇总起来。
					
					在统计segment元素数量的过程中，已统计过的segment瞬间插入新的元素,就会有影响
					
					ConcurrentHashMap的size方法是一个嵌套循环，大体逻辑如下：

						1.遍历所有的segment。
						2.把segment的元素数量累加起来。
						3.把segment的修改次数累加起来。
						4.判断所有segment的总修改次数是否大于上一次的总修改次数。如果大于，说明统计过程中有修改，重新统计，尝试次数+1；如果不是。说明没有修改，统计结束。
						5.如果尝试次数超过阈值，则对每一个segment加锁，再重新统计。
						6.再次判断所有segment的总修改次数是否大于上一次的总修改次数。由于已经加锁，次数一定和上次相等。
						7.释放锁，统计结束。
					
					为什么这样设计呢？这种思想和乐观锁悲观锁的思想如出一辙。
						为了尽量不锁住所有Segment，首先乐观地假设size过程中不会有修改。当尝试一定次数，才无奈转为悲观锁，锁住所有segment保证强一致性。
					
					那它是如何扩容的？
						concurrentHashMap采用的是端内扩容(段内元素超过该段对应Entry数组长度的75%触发扩容，不会对整个Map进行扩容),插入前检测是否需要扩容，避免无效扩容。
			2.1.7和1.8的区别
				①整体结构
					1.7:Segment + HashEntry + Unsafe
					1.8:移除Segment，使锁的粒度更小，Synchronized + CAS + Node + Unsafe

				②put()
					1.7:先定位Segment,再定位桶，put全程加锁，没有获取锁的线程提前找桶的位置，并最多自旋64次获取锁，超过则挂起，改为阻塞锁。
					1.8:由于移除了Segment，类似HashMap，可以直接定位到桶，拿到first节点后进行判断:①为空则CAS插入;②为-1则说明在扩容，则跟着一起扩容;③else 则加锁put（类似1.7）
				③get()
					基本类似，由于value声明为volatile，保证了修改的可见性，因此不需要加锁。

				④resize()
					1.7：跟HashMap步骤一样，只不过搬到单线程执行，避免了HashMap在1.7扩容时死循环的问题，保证线程安全。
					1.8:支持并发扩容，HashMap扩容时在1.8中由头插改为尾插(为了避免死循环)，ConcurrentHashMap也是，迁移也是从尾部开始，扩容前在桶的头部放置一个hash值为-1的节点，这样别的线程访问时就能判断是否该桶已经被其他线程处理过了。
					
				⑤size()
					1.7：很经典的思路:计算两次，如果不变则返回计算结果，若不一致，则锁住所有的segment求和。
					1.8:用baseCount来存储当前的节点个数，这涉及到baseCount并发环境下修改的问题。

					具体的实现方式比较复杂，如下：

					size()方法
					先利用sumCount()计算，然后如果值超过int的最大值，就返回int的最大值。但是有时size就会超过最大值，这时最好用mappingCount方法。
					sumCount有两个重要的属性baseCount和countCells，如果counterCells不为空，那么总共的大小就是baseCount与遍历CounterCells的value值累加获得的。
	3.其他的线程安全的集合框架
		1.Collections.synchronizedMap
			在SynchronizedMap内部维护了一个普通对象Map，还有排斥锁mutex。
			我们在调用这个方法的时候就需要传入一个Map，可以看到有两个构造器，如果传入了mutex参数，则将对象排斥锁赋值为传入的对象。
			如果没有，则将对象排斥锁赋值为this，即调用synchronizedMap的对象，就是上面的对象。

			创建出synchronizedMap之后，再操作map的时候，就会对方法上锁
		2.HashTable
			跟HashMap相比Hashtable是线程安全的，适合在多线程的情况下使用，但是效率不太乐观。

			因为它在对数据操作的时候都会上锁，所以效率比较低。
		 	
			HashTable和HashMap不同点
				①HashTable是不允许键或值为null的，HashMap的键值都可以为null。
					HashTable在put空值的时候会直接抛空指针异常，但是HashMap却做了特殊处理。
				
				②
					a.实现方式不同:HashTable继承了Dictionary类，而HashMap继承的是AbstractMap类。Dictionary是JDK1.0添加的。
					b.初始化容量不同:HashMap的初始容量为:16,HashTable初始容量为:11,两者的负载因子默认都是:0.75;
					
					c.扩容机制不同:当现有容量大于总容量 * 负载因子时，HashMap扩容规则为当前容量翻倍，HashTable扩容规则为当前容量翻倍+1.
					d.迭代器不同:HashMap中的Iterator迭代器是fail-fast的，而HashTable的Enumerator不是fail-fast的。
	4.treeMap、LinkedHashMap和HashMap进行对比
				HashMap							LinkedHashMap										TreeMap
	线程安全	否								否													否
	初始容量	16								16													0
	存储结构	数组+链表/红黑树				数组+链表/红黑树，HashMap子类						红黑树
	顺序规则	取值无顺序						取值按插入的顺序/按修改的顺序根据accessOrder控制	插入时按key的自然顺序或者自定义顺序		
																	
	存储特点	最多一条记录的key为null，可以多条记录value为null	同HashMap							
														(TreeMap)当为key的自然顺序存储时key不能为null，当自定义顺序时，通过传入的Comparator的实现控制
		
	插入效率	高								高													较高（因为需要不断Compare比较）
	遍历效率	高								较高（遍历后会改变存储顺序）						较高
	使用场景	使用最多，绝大多数无需排序的情况都可使用	需要插入的顺序和取出的顺序一样的情况下 需要按照key的自然顺序甚至于自定义顺序的情况下
	使用场景举例 (HashMap)....						(LinkedHashMap)如我们对领导进行排名，对城市的经济发展进行排名等	(TreeMap)如我们要展示周一到周五的消费情况，数据库里只取到了周二、周五的消费统计数据，这时将数据库的统计数据和手动构建消费为0的周一、三、五的数据按顺序组装，这时用TreeMap会非常方便
3.设计模式
	23种设计模式
		创建型：抽象工厂模式、建造者模式、工厂方法模式、原型模式、单例模式
		结构型:适配器模式、装饰模式、桥接模式、组合模式、享元模式、代理模式、外观模式	
		行为型:观察者模式、模板模式、命令模式、状态模式、职责链模式、解释器模式、中介者模式、访问者模式、策略模式、备忘录模式、迭代器模式
	5大基本原则
		单一职责原则
			单一职责原则（SRP),就一个类而言，应该仅有一个引起它变化的原因

		开放-封闭原则
			开放-封闭原则，是说软件实体（类、模块、函数等等）应该可以扩展，但是不可修改。

		依赖倒转原则
			抽象不应该依赖细节，细节应该依赖于抽象。

		里式代换原则
			里式代换原则（LSP）：子类型必须能够替代掉它们的父类型。

		迪米特法则
			迪米特法则，如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用


	1.单例模式
		优点： 
			1.在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就 防止其它对象对自己的实例化，确保所有的对象都访问一个实例 
			2.单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。 
			3.提供了对唯一实例的受控访问。 
			4.由于在系统内存中只存在一个对象，因此可以 节约系统资源，当 需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。 
			5.允许可变数目的实例。 
			6.避免对共享资源的多重占用。 
		缺点： 
			1.不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。 
			2.由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。 
			3.单例类的职责过重，在一定程度上违背了“单一职责原则”。 
			4.滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。 

		使用注意事项： 
			1.使用时不能用反射模式创建单例，否则会实例化一个新的对象 
			2.使用懒单例模式时注意线程安全问题 
			3.饿单例模式和懒单例模式构造方法都是私有的，因而是不能被继承的，有些单例模式可以被继承（如登记式模式） 
	2.责任链模式
		责任链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将整个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
		
	　　最显著的好处就是请求者不用知道到底是哪个对象处理的，反正提交请求就对了。

	　　同时链中的处理者并不知道整条链的结构，他们只需要保持一个指向下一任处理者对象的引用，这样非常大的降低了耦合度。 

	　　责任链模式的缺点是性能问题，有可能一个请求是从整条链的头部遍历到链尾部，应该尽量避免超长链，并且如果出现问题，调试很不方便。
	3.简单工厂、工厂方法与抽象工厂模式的区别。
		1.简单工厂:
			public class Factory {
				//可以在工厂类中添加任何你所需要的逻辑
				public static Product create(String str)
				{
					//生成ProductA
					if(str.equalsIgnoreCase("ProductA"))
					{
						return new ProductA();
					}
					else
						//生成ProductB
						if(str.equalsIgnoreCase("ProductB"))
						{
							return new ProductB();
						}
					return null;
				}

			}
			简单工厂模式实现了生成产品类的代码跟客户端代码分离，在工厂类中你可以添加所需的生产产品的逻辑代码，但是问题来了，优秀的java代码是符合“开发-封闭”原则的，也就是说对扩展开发，对修改关闭，如果要增加一个产品类C，就要修改工厂类里面的生成产品的代码，在这里就要增加if-else判断。对应这个问题，我们的工厂方法模式就可以解决这个问题。
			
		2.工厂方法:
			public interface Factory {
				//声明产生产品类的方法
				public Product createProduct();
			}
			
			public class FactoryA implements Factory {
				//实现工厂类的方法生成产品类A
				public Product createProduct()
				{
					return new ProductA();
				}

			}
			
			工厂方法模式中我们把生成产品类的时间延迟，就是通过对应的工厂类来生成对应的产品类，在这里我们就可以实现“开放-封闭”原则，无论增加多少产品类，我们都不用修改原来类中的代码，而是通过增加工厂类来实现。但是这还是有很多缺点的，如果产品类过多，我们就要生成很多的工厂类。假如我们要实现的产品接口不止一个，也就是有多个产品接口，不同接口有对应的产品族。对于这种情况我们可以采用抽象工厂模式。
		3.抽象工厂:
			public abstract class AbstractFactory {
			   public abstract Color getColor(String color);
			   public abstract Shape getShape(String shape);
			}
			
			public class ShapeFactory extends AbstractFactory {
    
			   @Override
			   public Shape getShape(String shapeType){
				  if(shapeType == null){
					 return null;
				  }        
				  if(shapeType.equalsIgnoreCase("CIRCLE")){
					 return new Circle();
				  } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
					 return new Rectangle();
				  } else if(shapeType.equalsIgnoreCase("SQUARE")){
					 return new Square();
				  }
				  return null;
			   }
			   
			   @Override
			   public Color getColor(String color) {
				  return null;
			   }
			}
			
			public class ColorFactory extends AbstractFactory {
    
			   @Override
			   public Shape getShape(String shapeType){
				  return null;
			   }
			   
			   @Override
			   public Color getColor(String color) {
				  if(color == null){
					 return null;
				  }        
				  if(color.equalsIgnoreCase("RED")){
					 return new Red();
				  } else if(color.equalsIgnoreCase("GREEN")){
					 return new Green();
				  } else if(color.equalsIgnoreCase("BLUE")){
					 return new Blue();
				  }
				  return null;
			   }
			}
			
			public class FactoryProducer {
			   public static AbstractFactory getFactory(String choice){
				  if(choice.equalsIgnoreCase("SHAPE")){
					 return new ShapeFactory();
				  } else if(choice.equalsIgnoreCase("COLOR")){
					 return new ColorFactory();
				  }
				  return null;
			   }
			}
			
			
		
4.ThreadLocal
	 ThreadLocal 对象可以提供线程局部变量，每个线程 Thread 拥有一份自己的 副本变量 ，多个线程互不干扰。
	
	1.ThreadLocal的数据结构
		 Thread 类有一个类型为 ThreadLocal.ThreadLocalMap 的实例变量 threadLocals ，也就是说每个线程有一个自己的 ThreadLocalMap 。
		
		 Thread  有自己的独立实现，可以简单地将它的 key 视作  ThreadLocal ， value 为代码中放入的值(实际上 key 并不是 ThreadLocal 本身，而是它的一个 弱引用 )。
		 
		每个线程在往 ThreadLocal 里放值的时候，都会往自己的 ThreadLocalMap 里存，读也是以 ThreadLocal 作为引用，在自己的 map 里找对应的 key ,从而实现了 线程隔离 。

		 ThreadLocalMap 有点类似 HashMap 的结构，只是 HashMap 是由 数组+链表 实现的，而 ThreadLocal 并没有 链表 结构。

		我们还要注意 Entry ,它的 key 是 ThreadLocal<?> k ，继承自 WeakReference ，也就是我们常说的弱类型。
	2.内存泄露
		假设在业务代码中使用完ThreadLocal，threadLocal Ref被回收了。

		由于ThreadLocalMap只持有ThreadLocal的弱引用，没有任何强引用指向threadLocal实例，所以threadLocal就可以顺利被gc回收，此时 Entry中的key=null 。

		但是在没有手动删除这个Entry以及CurrentThread依然运行的前提下，也存在强引用链threadRef -> currentThread -> threadLocalMap -> Entry -> value,value不会被回收， 而这块value永远不会被访问到了，导致value内存泄露 。

		内存泄露的真正原因是什么呢？

		有两个前提:

			- 没有手动删除这个Entry
			- CurrentThread依然运行

		第一点很好理解，只要在使用完ThreadLocal，调用其remove方法删除对应的Entry，就能避免内存泄露。
		第二点稍微复杂一点。由于ThreadLocalMap是Thread的一个属性，被当前线程所引用，所以它的生命周期跟Thread一样长，那么在使用完ThreadLocal之后，如果当前Thread也随之执行结束，ThreadLocalMap自然也会被gc回收，从根源上避免了内存泄露。
  
		 综上，ThreadLocal内存泄露的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应的key就会导致内存泄露 。
	3.ThreadLocal.set()方法
		 ThreadLocal 中的 set 方法原理，很简单，主要是判断 ThreadLocalMap 是否存在，然后使用 ThreadLocal 中的 set 方法进行数据处理。
	4.ThreadLocal的hash算法
		既然是 Map 结构，那么 ThreadLocalMap 当然也要实现自己的 hash 算法来解决散列表数组冲突问题。
			int i = key.threadLocalHashCode & (len-1);
		 ThreadLocalMap 中 hash 算法很简单，这里 i 就是当前key在散列表中对应的数组下标位置。
		这里最关键的就是 threadLocalHashCode 值的计算， ThreadLocal 中有一个属性为 HASH_INCREMENT = 0x61c88647 
		每当创建一个 ThreadLocal 对象，这个 ThreadLocal.nextHashCode 这个值就会增长 0x61c88647 .
		这个值很特殊，它是 斐波那契数 也叫 黄金分割数 。 hash 增量为这个数字，带来的好处就是 hash 分布非常均匀。
	5.ThreadLocalMap.set()
		往 ThreadLocalMap 中 set 数据(新增或更新数据)分为好几种情况。
		 第一种情况 :通过 hash 计算后的槽位对应的 Entry 数据为空:
			这里直接将数据放到该槽位即可。
			
		 第二种情况 :槽位数据不为空， key 值与当前 ThreadLocal 通过 hash 计算获取的 key 值一致。
			这里直接更新该槽位的数据。
		
		 第三种情况 ：槽位数据不为空，往后遍历中，在找到 Entry 为 null 的槽位之前，没有遇到 key 过期的 Entry :
			遍历散列数组，线性往后查找，如果找到 Entry 为 null 的槽位，则将数据放入该槽位中，或者往后遍历过程中，遇到了 key值相等 的数据，直接更新即可。
		
		 第四种情况 ：槽位数据不为空，往后遍历过程中，在找到 Entry 为 null 的槽位之前，遇到 key 过期的 Entry 
			表明此数据 key 值已经被垃圾回收掉了，此时就会执行 replaceStaleEntry() 方法，该方法的含义是 替换过期数据的逻辑 ，以 index=7 位起点开始遍历，进行探测式清理工作。

			初始化探测式清理过期数据扫描的开始位置: slotToExpunge = staleSlot = 7 
			以当前 staleSlot 开始向前迭代查找，找其他过期的数据，然后更新过期数据起始扫描下标 slotToExpunge 。 for 循环，直接碰到 Entry 为 null 结束。
			如果找到了过期的数据，继续向前迭代，直到遇到 Entry=null 的槽位才停止迭代。
			
			上面向前迭代的操作是为了更新探测清理过期数据的起始下标 slotToExpunge 的值，这个值后面会讲，它是用来判断当前过期槽位 staleSlot 之前是否还有过期元素。

			接着开始以 staleSlot 位置 (index=7) 向后迭代， 如果找到了相同key值的Entry数据 ：
			
			从当前节点 staleSlot 向后查找 key 相等的 Entry 元素，找到后更新 Entry  的值并交换 staleSlot 元素的位置( staleSlot 位置为过期元素),更新 Entry 数据，然后开始进行过期 Entry 的清理工作。
			
			向后遍历过程中，如果没有找到相同key值的Entry数据：
			
			从当前节点 staleSlot 向后查找 key 相等的 Entry 元素，直到 Entry 为 null 则停止寻找。此时 table 中若没有 key 值相同的 Entry .
			
			创建新的 Entry ，替换 table[staleSlot] 位置:
			替换完成后也是进行过期元素清理工作，清理工作只要是有两个方法: expungeStaleEntry() 和 cleanSomeSlots ，具体细节后面讲。
	6.ThreadLocalMap的get()方法
		 第一种情况 :通过查找 key 值计算出散列表中 slot 位置，然后该 slot 位置中的 Entry.key 和查找的 key 一致，则会直接返回:
		
		 第二种情况 : slot 位置中的 Entry.key 和要查找的 key 不一致:
			我们以 get(ThreadLocal) 为例，通过 hash 计算后，正确的 slot 位置应该是4，而 index=4 的槽位已经有了数据，且 key 值不等于 ThreadLocal1 ，然后需要继续往后迭代查找。

			迭代到 index = 5 的数据时，此时 Entry.key = null ，触发一次探测式数据回收操作，执行 expungeStaleEntry() 方法，执行完后， index 5, 8 的数据都会被回收，而 index 6,7 的数据都会前移， 
	7.ThreadLocalMap扩容机制
		在 ThreadLocalMap.set() 方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中Entry的数量已经达到了列表的扩容阈值 (len * 2 / 3) ，就开始执行 rehash() 逻辑:	
		这里首先是会进行探测式清理工作，从 table 的起始位置往后清理，上面有分析清理的详细流程。清理完成之后， table 中可能有一些 key 为 null 的 Entry 数据被清理掉，所以此时通过判断 size >= thread - thread / 4 也就是 size >= threshold * 3 / 4 来决定是否扩容。

		记得上面进行 rehash() 的阈值是 size >= threshold ,所以当面试官套路我们 ThreadLocalMap 扩容机制的时候，一定要记清楚。
	8.过期key的探测式清理
		我们先讲下探测式清理，也即是 expungeStaleEntry 方法，遍历散列数组，从开始位置向后探测清理过期数据，将过期数据的 Entry 设置为 null ，沿途中碰到未过期的数据将此数据 rehash 后重新在 table 数组中定位，如果定位的位置已经有了数组，则会将未过期的数据放到最靠近此位置的 Entry = null 的桶中，使 rehash 后的 Entry 数据距离正确的桶的位置更近一些。
	9.ThreadLocalMap过期key的启发式清理流程
		以启发式的方式进行检测，通过探测获取过期key，然后逐步除2.
	10.应用场景
		为了说明ThreadLocal的应用场景。我们来看一个框架的样例。Spring的事务管理器通过AOP切入业务代码，在进入业务代码前，会依据相应的事务管理器提取出相应的事务对象，假如事务管理器是DataSourceTransactionManager，就会从DataSource中获取一个连接对象，通过一定的包装后将其保存在ThreadLocal中。而且Spring也将DataSource进行了包装，重写了当中的getConnection()方法，或者说该方法的返回将由Spring来控制，这样Spring就能让线程内多次获取到的Connection对象是同一个。
		为什么要放在ThreadLocal里面呢？由于Spring在AOP后并不能向应用程序传递參数。应用程序的每一个业务代码是事先定义好的，Spring并不会要求在业务代码的入口參数中必须编写Connection的入口參数。此时Spring选择了ThreadLocal，通过它保证连接对象始终在线程内部，不论什么时候都能拿到，此时Spring很清楚什么时候回收这个连接，也就是很清楚什么时候从ThreadLocal中删除这个元素