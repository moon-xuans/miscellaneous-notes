1.八股文
	1.OSI与TCP/IP各层的功能？
		计算机网络体系可以大致分为一下三种，OSI七层模型、TCP/IP四层模型和五层模型。
		OSI七层模型：大而全，但是比较复杂、而且是先有了理论模型，没有实际应用。
		TCP/IP四层模型：是由实际应用发展总结出来的，从实质上讲，TCP/IP只有最上面三层，最下面一层没有什么具体内容，TCP/IP参考模型没有真正描述这一层的实现。
		
		五层模型：五层模型只出现在计算机网络教学过程中，这是对七层模型和四层模型的一个折中，既简洁又能将概念阐述清楚。
		
		1.应用层：
			功能：应用层的任务是通过应用进程间的交互来完成特定网络应用
		(表示层：主要负责数据格式的转换，如加密解密、转换翻译、压缩解压缩等。
		会话层：负责在网络中的两节点之间建立、维持和终止通信，如服务器验证用户登录便是由会话层完成的。)
		2.运输层：
			功能：运输层的任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。
		3.网络层：
			功能：网络层的任务就是选择合适的网间路由和交换结点，确保数据及时传送。
		4.数据链路层：
			功能：在两个相邻节点之间传输数据时，数据链路层将网络层交下来的IP数据报组装成帧，在两个相邻节点间的链路上传送帧。
		5.物理层
			功能：物理层的作用是实现相邻计算机节点之间比特流的透明传输，尽可能屏蔽掉具体传输介质和物理设备的差异。
	2.TCP，UDP协议的区别
		类型	是否面向连接	传输可靠性	传输形式	传输效率	所需资源	应用场景			首部字节
		TCP		面向连接		可靠		字节流		慢			多			要求通信数据可靠	20-60
		UDP		无连接			不可靠		数据报文段	快			少			要求通信速度高		8个字节
	3.UDP和TCP对应的应用场景是什么？
		TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：
			FTP文件传输
			HTTP / HTTPS
		UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：
			包总量较少的通信，如 DNS 、SNMP等
			视频、音频等多媒体通信
			广播通信
	5.状态码
				类别								原因短语
		1XX		Informational（信息性状态码）		接收的请求正在处理
		2XX		Success（成功状态码）				请求正常处理完毕
		3XX		Redirection（重定向状态码）			需要进行附加操作以完成请求
			300	Multiple Choices	多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择
			
			301	Moved Permanently		永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
			
			302	Found	临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI
			
			303	See Other	查看其它地址。与301类似。使用GET和POST请求查看
		4XX		Client Error（客户端错误状态码）	服务器无法处理请求
		5XX 	Server Error（服务器错误状态码）	服务器处理请求错误

	6.HTTP长连接，短连接
		在HTTP/1.0默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。
		而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：Connection：keep-alive
		在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。
	7.HTTP是不保存状态的协议，如何保存用户状态？
		Session机制的存在就是为了解决这个问题，Session的主要作用就是通过服务端记录用户的状态。
		
		既然Session存放在服务器端，那么我们如何实现Session跟踪呢？
			大部分情况下，我们都是通过Cookie中附加一个Session ID的方式来跟踪。
		
		Cookie被禁用怎么办？
			最常见的就是利用URL重写把Session ID直接附加在URL路径的后面。
		
	8.Cookie的作用是什么？和Session有什么区别？
		Cookie一般用来保存用户信息
		Session的主要作用就是通过服务端记录用户的状态。
		
		Cookie数据保存在客户端（浏览器端），Session数据保存在服务器端。
		
		相对来说，Session安全性更高。如果要在Cookie中存储一些敏感信息，不要直接写入Cookie中，最好能将Cookie信息加密然后使用到的时候再去服务器端解密。
	9.URI和URL的区别是什么？
		URI（Uniform Resource Identifier）是统一资源标志符，可以唯一标识一个资源。
		URL（Uniform Resource Location）是统一资源定位符，可以用来提供该资源的路径。它是一种具体的URI,即URL可以用来表示一个资源，而且还指明了如何locate这个资源。
	10.HTTP和HTTPS的区别？
		1.端口：HTTP的URL由"http://"起始且默认使用端口80，而HTTPS的URL由"https://"起始且默认使用端口443
		2.安全性和资源消耗：HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP请求，SSL/TLS运行在TCP之上。所有传输的内容多经过加密。所以说，HTTP安全性没有HTTPS高，但是HTTPS比HTTP耗费更多服务器资源。

2.TCP
	1.三次握手和四次挥手
		1.三次握手
			1.过程：
				1.第一次握手：客户端请求建立连接，向服务端发送一个同步报文（SYN=1），同时选择一个随机数
				seq = x 作为初始序列号，并进入SYN_SENT状态，等待服务器确认。
				2.第二次握手：：服务端收到连接请求报文后，如果同意建立连接，则向客户端发送同步确认报文
				（SYN=1，ACK=1），确认号为 ack = x + 1，同时选择一个随机数 seq = y 作为初始序列号，此时
				服务器进入SYN_RECV状态。
				3.第三次握手：客户端收到服务端的确认后，向服务端发送一个确认报文（ACK=1），确认号为 ack
				= y + 1，序列号为 seq = x + 1，客户端和服务器进入ESTABLISHED状态，完成三次握手。
				 
				理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。
				
				
				(seq作用:TCP通过数据分段中的序列号来保证所有传输的数据可以按照正常的顺序进行重组，从而保障数据传输的完整。)
			2.为什么需要三次握手，而不是两次？
				主要有三个原因：
					1. 防止已过期的连接请求报文突然又传送到服务器，因而产生错误和资源浪费。
						在双方两次握手即可建立连接的情况下，假设客户端发送 A 报文段请求建立连接，由于网络原因造
						成 A 暂时无法到达服务器，服务器接收不到请求报文段就不会返回确认报文段。
						客户端在长时间得不到应答的情况下重新发送请求报文段 B，这次 B 顺利到达服务器，服务器随即
						返回确认报文并进入 ESTABLISHED 状态，客户端在收到 确认报文后也进入 ESTABLISHED 状态，
						双方建立连接并传输数据，之后正常断开连接。
						此时姗姗来迟的 A 报文段才到达服务器，服务器随即返回确认报文并进入 ESTABLISHED 状态，但
						是已经进入 CLOSED 状态的客户端无法再接受确认报文段，更无法进入 ESTABLISHED 状态，这将
						导致服务器长时间单方面等待，造成资源浪费。
					2. 三次握手才能让双方均确认自己和对方的发送和接收能力都正常。
						第一次握手：客户端只是发送处请求报文段，什么都无法确认，而服务器可以确认自己的接收能力
						和对方的发送能力正常；
						第二次握手：客户端可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；
						第三次握手：服务器可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；
						可见三次握手才能让双方都确认自己和对方的发送和接收能力全部正常，这样就可以愉快地进行通
						信了。
					3. 告知对方自己的初始序号值，并确认收到对方的初始序号值。
						TCP 实现了可靠的数据传输，原因之一就是 TCP 报文段中维护了序号字段和确认序号字段，通过
						这两个字段双方都可以知道在自己发出的数据中，哪些是已经被对方确认接收的。这两个字段的值
						会在初始序号值的基础递增，如果是两次握手，只有发起方的初始序号可以得到确认，而另一方的
						初始序号则得不到确认
			3. 为什么要三次握手，而不是四次？
				因为三次握手已经可以确认双方的发送接收能力正常，双方都知道彼此已经准备好，而且也可以完成对
				双方初始序号值得确认，也就无需再第四次握手了。
				第一次握手：服务端确认“自己收、客户端发”报文功能正常。
				第二次握手：客户端确认“自己发、自己收、服务端收、客户端发”报文功能正常，客户端认为连接已建立。
				第三次握手：服务端确认“自己发、客户端收”报文功能正常，此时双方均建立连接，可以正常通信。
			4. 什么是 SYN洪泛攻击？如何防范？
				SYN洪泛攻击属于 DOS 攻击的一种，它利用 TCP 协议缺陷，通过发送大量的半连接请求，耗费 CPU 和内存资源。
				
				原理：
					1.在三次握手过程中，服务器发送 [SYN/ACK] 包（第二个包）之后、收到客户端的 [ACK] 包（第三
					个包）之前的 TCP 连接称为半连接（half-open connect），此时服务器处于 SYN_RECV（等待客
					户端响应）状态。如果接收到客户端的 [ACK]，则 TCP 连接成功，如果未接受到，则会不断重发请
					求直至成功。
					2.SYN 攻击的攻击者在短时间内伪造大量不存在的 IP 地址，向服务器不断地发送 [SYN] 包，服务器
					回复 [SYN/ACK] 包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超
					时。
					3.这些伪造的 [SYN] 包将长时间占用未连接队列，影响了正常的 SYN，导致目标系统运行缓慢、网络
					堵塞甚至系统瘫痪。
				
				检测：当在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次
				SYN 攻击。
				
				防范：
					1.通过防火墙、路由器等过滤网关防护。
					2.通过加固 TCP/IP 协议栈防范，如增加最大半连接数，缩短超时时间。
					3.SYN cookies技术。SYN Cookies 是对 TCP 服务器端的三次握手做一些修改，专门用来防范 SYN
					洪泛攻击的一种手段。
			5.三次握手连接阶段，最后一次ACK包丢失，会发生什么？
				服务端：
					第三次的ACK在网络中丢失，那么服务端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重
					传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便客户端重新发送ACK包。
					如果重发指定次数之后，仍然未收到 客户端的ACK应答，那么一段时间后，服务端自动关闭这个连
					接。
				客户端：
					客户端认为这个连接已经建立，如果客户端向服务端发送数据，服务端将以RST包（Reset，标示复位，
					用于异常的关闭连接）响应。此时，客户端知道第三次握手失败。
					
		2.四次挥手：
			1.过程：
				第一次挥手：客户端向服务端发送连接释放报文（FIN=1，ACK=1），主动关闭连接，同时等待服务端的确认。
					序列号 seq = u，即客户端上次发送的报文的最后一个字节的序号 + 1
					确认号 ack = k, 即服务端上次发送的报文的最后一个字节的序号 + 1
				第二次挥手：服务端收到连接释放报文后，立即发出确认报文（ACK=1），序列号 seq = k，确认号 ack = u + 1。
				
				这时 TCP 连接处于半关闭状态，即客户端到服务端的连接已经释放了，但是服务端到客户端的连接
				还未释放。这表示客户端已经没有数据发送了，但是服务端可能还要给客户端发送数据。
				
				第三次挥手：服务端向客户端发送连接释放报文（FIN=1，ACK=1），主动关闭连接，同时等待 A
				的确认。
					序列号 seq = w，即服务端上次发送的报文的最后一个字节的序号 + 1。
					确认号 ack = u + 1，与第二次挥手相同，因为这段时间客户端没有发送数据
				第四次挥手：客户端收到服务端的连接释放报文后，立即发出确认报文（ACK=1），序列号 seq =
				u + 1，确认号为 ack = w + 1。
				
				此时，客户端就进入了 TIME-WAIT 状态。注意此时客户端到 TCP 连接还没有释放，必须经过
				2*MSL（最长报文段寿命）的时间后，才进入 CLOSED 状态。而服务端只要收到客户端发出的确
				认，就立即进入 CLOSED 状态。可以看到，服务端结束 TCP 连接的时间要比客户端早一些。
			2.为什么连接的时候是三次握手，关闭的时候却是四次握手？
				服务器在收到客户端的 FIN 报文段后，可能还有一些数据要传输，所以不能马上关闭连接，但是会做出
				应答，返回 ACK 报文段.
				接下来可能会继续发送数据，在数据发送完后，服务器会向客户单发送 FIN 报文，表示数据已经发送完
				毕，请求关闭连接。服务器的ACK和FIN一般都会分开发送，从而导致多了一次，因此一共需要四次挥
				手。
			3. 为什么客户端的 TIME-WAIT 状态必须等待 2MSL ？
				主要有两个原因：
					1. 确保 ACK 报文能够到达服务端，从而使服务端正常关闭连接。
						第四次挥手时，客户端第四次挥手的 ACK 报文不一定会到达服务端。服务端会超时重传 FIN/ACK
						报文，此时如果客户端已经断开了连接，那么就无法响应服务端的二次请求，这样服务端迟迟收不
						到 FIN/ACK 报文的确认，就无法正常断开连接。
						MSL 是报文段在网络上存活的最长时间。客户端等待 2MSL 时间，即「客户端 ACK 报文 1MSL 超 时 + 服务端 FIN 报文 1MSL 传输」，就能够收到服务端重传的 FIN/ACK 报文，然后客户端重传一
						次 ACK 报文，并重新启动 2MSL 计时器。如此保证服务端能够正常关闭。
						如果服务端重发的 FIN 没有成功地在 2MSL 时间里传给客户端，服务端则会继续超时重试直到断开
						连接。
					2. 防止已失效的连接请求报文段出现在之后的连接中。
						TCP 要求在 2MSL 内不使用相同的序列号。客户端在发送完最后一个 ACK 报文段后，再经过时间
						2MSL，就可以保证本连接持续的时间内产生的所有报文段都从网络中消失。这样就可以使下一个
						连接中不会出现这种旧的连接请求报文段。或者即使收到这些过时的报文，也可以不处理它。
			4.TIME-WAIT 状态过多会产生什么后果？怎样处理？
				从服务器来讲，短时间内关闭了大量的Client连接，就会造成服务器上出现大量的TIME_WAIT连接，严
				重消耗着服务器的资源，此时部分客户端就会显示连接不上。
				
				从客户端来讲，客户端TIME_WAIT过多，就会导致端口资源被占用，因为端口就65536个，被占满就会
				导致无法创建新的连接。
				
				解决办法：
					1.服务器可以设置 SO_REUSEADDR 套接字选项来避免 TIME_WAIT状态，此套接字选项告诉内核，
					即使此端口正忙（处于 TIME_WAIT状态），也请继续并重用它。
					2.调整系统内核参数，修改/etc/sysctl.conf文件，即修改net.ipv4.tcp_tw_reuse 和 tcp_timestamps
					net.ipv4.tcp_tw_reuse = ``1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接， 默认为``0``，表示关闭； net.ipv4.tcp_tw_recycle = ``1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为``0``，表示关闭。
					3.强制关闭，发送 RST 包越过TIME_WAIT状态，直接进入CLOSED状态。
			5.TIME_WAIT 是服务器端的状态?还是客户端的状态?
				TIME_WAIT 是主动断开连接的一方会进入的状态，一般情况下，都是客户端所处的状态;服务器端一般
				设置不主动关闭连接。
				TIME_WAIT 需要等待 2MSL，在大量短连接的情况下，TIME_WAIT会太多，这也会消耗很多系统资源。
				对于服务器来说，在 HTTP 协议里指定 KeepAlive（浏览器重用一个 TCP 连接来处理多个 HTTP 请
				求），由浏览器来主动断开连接，可以一定程度上减少服务器的这个问题。
	2.TCP协议如何保证可靠性？
		TCP主要提供了检验和、序列号/确认应答、超时重传、滑动窗口、拥塞控制和 流量控制等方法实现了可
		靠性传输。
		1.检验和：通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢
		弃TCP段，重新发送。
		2.序列号/确认应答：
			1.序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重
			复序列号的数据。
			2.TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文，
			这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里
			发。
		3.滑动窗口：滑动窗口既提高了报文传输的效率，也避免了发送方发送过多的数据而导致接收方无法
		正常处理的异常。
		4.超时重传：超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被
		认为是丢包了，需要重传。最大超时时间是动态计算的。
		5.拥塞控制：在数据传输过程中，可能由于网络状态的问题，造成网络拥堵，此时引入拥塞控制机
		制，在保证TCP可靠性的同时，提高性能。
		6.流量控制：如果主机A 一直向主机B发送数据，不考虑主机B的接受能力，则可能导致主机B的接受
		缓冲区满了而无法再接受数据，从而会导致大量的数据丢包，引发重传机制。而在重传的过程中，
		若主机B的接收缓冲区情况仍未好转，则会将大量的时间浪费在重传数据上，降低传送数据的效
		率。所以引入流量控制机制，主机B通过告诉主机A自己接收缓冲区的大小，来使主机A控制发送的
		数据量。流量控制与TCP协议报头中的窗口大小有关。		
			
	3.详细讲一下TCP的滑动窗口？
		在进行数据传输时，如果传输的数据比较大，就需要拆分为多个数据包进行发送。TCP 协议需要对数据
		进行确认后，才可以发送下一个数据包。这样一来，就会在等待确认应答包环节浪费时间。
		
		为了避免这种情况，TCP引入了窗口概念。窗口大小指的是不需要等待确认应答包而可以继续发送数据
		包的最大值。
		
		(从上面的图可以看到)滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。
		
		滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。随
		着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没
		轮到的分组进入窗口内。
		
		可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前 TCP 发送包的速
		率，而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。		
	4.详细讲一下拥塞控制？
		TCP 一共使用了四种算法来实现拥塞控制：
			慢开始 (slow-start)；
			拥塞避免 (congestion avoidance)；
			快速重传 (fast retransmit)；
			快速恢复 (fast recovery)。
			
		发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。当cwndssthresh时，改用拥
		塞避免算法。
		
		慢开始：不要一开始就发送大量的数据，由小到大逐渐增加拥塞窗口的大小。
		
		拥塞避免：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd
		加1而不是加倍。这样拥塞窗口按线性规律缓慢增长。
		
		快重传：我们可以剔除一些不必要的拥塞报文，提高网络吞吐量。比如接收方在收到一个失序的报文段
		后就立即发出重复确认，而不要等到自己发送数据时捎带确认。快重传规定：发送方只要一连收到三个
		重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。
		
		快恢复：主要是配合快重传。当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh
		门限减半（为了预防网络发生拥塞），但接下来并不执行慢开始算法，因为如果网络出现拥塞的话就不
		会收到好几个重复的确认，收到三个重复确认说明网络状况还可以。		
3.HTTPS
	1.存在的问题
		http是应用层的协议，位于TCP/IP参考模型的最上层。用户数据经过应用层、传输层、网络层、链路层的层层封装后经过物理层发送到目标机器。在这几层中，数据都没有经过加密处理，所以一旦别人获取到你的数据包，就能轻易的获取到数据的信息。
	2.对称加密
		对称加密算法的加密和解密都是用同一个密钥。在一定条件下，对称加密可以解决数据传输安全性的问题。
		
		那也就是说客户端与服务端通信之前应该先协商密钥，而这个时候如果被截获了协商密钥的数据，那相当于未加密。因此对称加密存在密钥协商的问题。
	3.非对称加密
		基于对称加密存在的问题，又有了非对称加密。非对称加密算法需要一组密钥对，分别是公钥和私钥，这两个密钥是成对出现的。公钥加密的内容需要用私钥解密，私钥加密的内容需要用公钥解密！私钥由服务器自己保存，公钥发送给客户端。客户端拿到公钥后就可以对请求进行加密后发送给服务端了，这时候就算被截获，没有私钥也无法解密发送的内容，这样确保了客户端发送到服务端数据的“安全”！但是由于公钥也需要通过网络发送给客户端，同样能被截获，这样服务器私钥加密后的内容依然可以被截获并解密，并且非对称加密的效率很低。
		对称加密和非对称加密都存在密钥传输的问题，但是至少非对称加密可以保证客户端传输给服务端的内容无法被“破解”，而对称加密算法性能又比较好，那我们是不是可以这样子呢。第一次通信的时候服务端发送公钥给客户端，由客户端产生一个对称密钥，通过服务端的公钥加密后发送给服务端，后续的交互中都通过对称密钥进行加密传输。也就是说先通过非对称密钥加密对称密钥，通过对称密钥加密实际请求的内容。
		
		但是也存在一个问题，任何人可以伪装成服务器，与客户端进行通信。类似于你与服务端之间多了一个中间商！也就是说协商密钥的过程依然存在漏洞。
		
		 在协商密钥的过程中，客户端怎么能确定对方是真正的目标服务器呢，怎么证明服务器的身份呢，了解一下数字证书。
	4.数字证书
		那服务器是不是也能有个类似身份证的东西，在与服务器进行通信的时候证明自己确实是目标服务器而伪造的呢？在生活中这些证件都是事实在在能看得见摸得着的，而计算机中的证书是虚拟的，看得见但是摸不着，是数据形式记录的，所以叫数字证书！
		客户端第一次与服务器进行通信的时候，服务器需要出示自己的数字证书，证明自己的身份以及自己的公钥。
		
		那这个数字证书怎么产生的呢？总不能是服务器自己造一个吧？上面说到了我们生活中的证书是由权威机构颁发的、无法伪造的，那我们数字证书也应该有这两个特性-权威机构颁发、防伪！
	5.CA机构
		CA机构就是数字证书颁发的权威机构，负责颁发证书以及验证证书的合法性。
		客户端在拿到服务器的证书后，就需要验证证书编号是否能在对应的CA机构查到，并且核对证书的基本信息如证书上的域名是否与当前访问的域名一致等等，还可以拿到证书中服务器的公钥信息用于协商对称密钥！
		证书颁发了，可是又怎么防止伪造，怎么保证在传输过程中不被篡改呢？因此需要数字签名了。
	6.数字签名
		与公司签过劳动合同的朋友应该都知道，在合同信息的填写中，是不能有涂改的，否则需要重新填写！并且在最后需要甲方和乙方签名并且盖章。一旦签名盖章后的合同就具有了法律的效力，合同就不能再修改。签名和盖章操作就是防止合同伪造，规定不能修改就防止了合同被篡改！
		我们在做权限系统的时候，存储用户密码的时候都会经过MD5计算摘要后存储，在登录的时候计算用户填写的密码的MD5摘要与数据库存储的摘要进行对比，如果一致则密码正确，否则登录失败！MD5是不可逆的，且不同的数据计算出来的摘要是不一样的（当然也有极小的概率会hash碰撞），基于这个特性，就有了数字签名的思路。
		服务器提交自己的基本信息想CA机构提出申请，CA机构在给服务器颁发证书的时候，会连同数字证书以及根据证书计算的摘要一同发送给服务器，且这个摘要是需要经过CA机构自己的私钥进行加密的。
		
		服务器在与客户端通信的时候，就会将数字证书和数字签名出示给客户端了。客户端拿到数字证书和数字签名后，先通过操作系统或者浏览器内置信任的CA机构找到对应CA机构的公钥对数字签名进行解密，然后采用同样的摘要算法计算数字证书的摘要，如果自己计算的摘要与服务器发来的摘要一致，则证书是没有被篡改过的！这样就防止了篡改！第三方拿不到CA机构的私钥，也就无法对摘要进行加密，如果是第三方伪造的签名自然也在客户端也就无法解密，这就防止了伪造！所以数字签名就是通过这种机制来保证数字证书被篡改和被伪造。
	7.HTTPS
		本文的标题是HTTPS，但是到目前为止HTTPS只字未提！其实HTTPS=HTTP+SSL，在HTTP层和TCP之间加了一个SSL/TLS层
	
		SSL（Secure Sockets Layer）中文叫“安全套接层”，后来由于广泛应用，SSL标准化之后就改名为TLS（Transport Layer Security）了,其实HTTPS就是通过上面说到的那些手段来解决网络上可能存在的数据泄密、篡改、假冒的这些问题，保证网络传输的安全的
4.在浏览器中输入URL后，执行的全部过程。会用到哪些协议？（一次完整的HTTP请求过程）
	整个流程如下：
	　　a.域名解析
	　　b.为了将消息从你的PC上传到服务器上，需要用到IP协议、ARP协议和OSPF协议。
	　　c.发起TCP的三次握手
	　　d.建立TCP连接后发起HTTP请求
	　　e.服务器响应HTTP请求
	　　f.浏览器解析html代码，并请求HTML代码中的资源（如js、css、图片等）
	　　g.断开TCP连接
	　　h.浏览器对页面进行渲染呈现给用户
	
	
	域名解析
		比如要查询www.baidu.com的IP地址：
		　　1、浏览器搜索自己的DNS缓存（维护一张域名与IP地址的对应表）；
		　　2、若没有，则搜索操作系统中的DNS缓存（维护一张域名与IP地址的对应表）；
		　　3、若没有，则搜索操作系统的hosts文件（Windows环境下，维护一张域名与IP地址的对应表）；
		　　4、若没有，则操作系统将域名发送至本地域名服务器---（递归查询方式），本地域名服务器查询自己的DNS缓存，查找成功则返回结果，否则，（以下是迭代查询方式）
		　　　　4.1. 
				本地域名服务器向根域名服务器（其虽然没有每个域名的具体信息，但存储了负责每个域，如com、net、org等解析的顶级域名服务器的地址）发起请求，此处，根域名服务器返回com域的顶级域名服务器的地址；
		　　　　4.2. 
				本地域名服务器向com域的顶级域名服务器发起请求，返回baidu.com权限域名服务器（权限域名服务器，用来保存该区中的所有主机域名到IP地址的映射）地址；
		　　　　4.3.
				本地域名服务器向baidu.com权限域名服务器发起请求，得到www.baidu.com的IP地址；
		　　5、本地域名服务器将得到的IP地址返回给操作系统，同时自己也将IP地址缓存起来；
		　　6、操作系统将IP地址返回给浏览器，同时自己也将IP地址缓存起来；
		　　7、至此，浏览器已经得到了域名对应的IP地址；
		
	 ARP（地址解析协议）	
		ARP解决的是同一个局域网内，主机或路由器的IP地址和MAC地址的映射问题。如果源主机和目的主机在同一个局域网内（目标IP和本机IP分别与子网掩码相与的结果相同，那么它们在一个子网），就可以用ARP找到目的主机的MAC地址；如果不在一个局域网内，用ARP协议找到本网络内的一个路由器的MAC地址，剩下的工作有这个路由器来完成。

	　　ARP协议的具体内容：
			　　（1）每个主机都会有ARP高速缓存，存储本局域网内IP地址和MAC地址之间的对应关系。
			　　（2）当源主机要发送数据时，首先检查ARP高速缓存中是否有对应IP地址目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP请求分组，该数据包包括的内容有：（源主机IP地址，源主机MAC地址，目的主机的IP地址）。
			　　（3）当本网络的所有主机收到该ARP请求分组时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包；如果是，则首先从数据包中取出源主机的IP地址和MAC地址写入到ARP高速缓存中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。
			　　（4）源主机收到ARP响应分组后，将目的主机的IP和MAC地址写入ARP高速缓存中，并利用此信息发送数据。如果源主机一直没有收到ARP响应分组，表示ARP查询失败。
			
	路由选择协议
		　　网络层主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，通过查找路由表决定通过哪个路径到达服务器，其中用到路由选择协议。

		有两大类路由选择协议
			1、内部网关协议
			　　内部网关协议IGP（Internet Gateway Protocol）即在一个自治系统内部使用的路由选择协议，RIP和OSRF协议和IS-IS协议，IGRP（内部网关路由协议）、EIGRP（增强型内部网关路由协议）。
				（1）RIP（应用层协议，基于UDP）
				　　　RIP是一种基于距离向量的路由选择协议。RIP协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。这里的“距离”实际上指的是“最短距离”。只能包含15个路由器。RIP认为一个好的路由就是它通过的路由器的数量少，即“距离短”。RIP允许一条路径最多只能包含15个路由器。“距离”的最大值为16是即相当于不可达。RIP选择一个具有最少路由器的路由（即最短路由），哪怕还存在另一条高速（低时延）但路由器较多的路由。
				（2）OSPF（网络层协议）
				　　　“最短路径优先”是因为使用了Dijkstra提出的最短路径算法。使用洪范法向本自治系统中所有路由器发送信息。发送的信息就是与本路由器相邻的所有路由器的链路状态（“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”），但这只是路由器所知道的部分信息。只有当链路状态发生变化时，路由器才用洪范法向所有路由器发送此信息。
			2、外部网关协议
			
				（1）BGP协议（应用层协议，基于TCP的）
				　　BGP是不同自治系统的路由器之间交换路由信息的协议。边界网关协议BGP只能是力求寻找一条能过到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由。
				　　BGP发言人：每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“BGP发言人”/一般来说，两个BGP发言人都是通过一个共享网络连接在一起的，而BGP发言人往往就是BGP边界路由器，但也可以不是BGP边界路由器。
				　　BGP交换路由信息：一个BGP发言人与其他自治系统中的BGP发言人要交换信息，就要先建立TCP连接，然后在此连接上交换BGP报文以建立BGP会话（session），利用BGP会话交换路由信息。使用TCP连接能提供可靠的服务也简化了路由选择协议。使用TCP连接交换路由信息的两个BGP发言人，彼此成为对方的临站或对等站。BGP所交换的路由信息就是到达某个网络所要经过的一系列AS。
	
	路由分组转发算法
		　　（1）首先从IP数据报首部提取目的主机的IP地址D，得出其所在的网络N。
		　　（2）若N就是与此路由器直接相连的某个网络，则进行直接交付，直接把数据报交付给目的主机。否则就执行（3）。
		　　（3）若路由表中有目的地址为D的特定主机路由，则把数据报传给路由表中所指明的下一跳路由器。否则执行（4）。
		　　（4）若路由表中有到达网络N的路由，则把数据报传给路由表中所指明的下一跳路由器。否则执行（5）。
		　　（5）若路由表中有一个默认路由，则把数据报传给默认路由所指明的默认路由器。否则执行（6）。
		　　（6）报告转发分组出错。

	路由器与交换机的区别是什么？
		　　1）交换机工作在数据链路层；路由器工作在网络层；
		　　2）交换机转发数据帧；路由器转发IP组；
		　　3）交换机隔离冲突域，不隔离广播域；路由器隔离冲突域，隔离广播域；